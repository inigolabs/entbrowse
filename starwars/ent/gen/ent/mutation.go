// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"

	"github.com/inigolabs/entbrowse/starwars/ent/gen/ent/film"
	"github.com/inigolabs/entbrowse/starwars/ent/gen/ent/person"
	"github.com/inigolabs/entbrowse/starwars/ent/gen/ent/planet"
	"github.com/inigolabs/entbrowse/starwars/ent/gen/ent/predicate"
	"github.com/inigolabs/entbrowse/starwars/ent/gen/ent/species"
	"github.com/inigolabs/entbrowse/starwars/ent/gen/ent/starship"
	"github.com/inigolabs/entbrowse/starwars/ent/gen/ent/vehicle"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeFilm     = "Film"
	TypePerson   = "Person"
	TypePlanet   = "Planet"
	TypeSpecies  = "Species"
	TypeStarship = "Starship"
	TypeVehicle  = "Vehicle"
)

// FilmMutation represents an operation that mutates the Film nodes in the graph.
type FilmMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	director            *string
	episode_id          *int
	addepisode_id       *int
	opening_crawl       *string
	producer            *string
	title               *string
	clearedFields       map[string]struct{}
	has_person          map[int]struct{}
	removedhas_person   map[int]struct{}
	clearedhas_person   bool
	has_planet          map[int]struct{}
	removedhas_planet   map[int]struct{}
	clearedhas_planet   bool
	has_starship        map[int]struct{}
	removedhas_starship map[int]struct{}
	clearedhas_starship bool
	has_vehicle         map[int]struct{}
	removedhas_vehicle  map[int]struct{}
	clearedhas_vehicle  bool
	has_species         map[int]struct{}
	removedhas_species  map[int]struct{}
	clearedhas_species  bool
	done                bool
	oldValue            func(context.Context) (*Film, error)
	predicates          []predicate.Film
}

var _ ent.Mutation = (*FilmMutation)(nil)

// filmOption allows management of the mutation configuration using functional options.
type filmOption func(*FilmMutation)

// newFilmMutation creates new mutation for the Film entity.
func newFilmMutation(c config, op Op, opts ...filmOption) *FilmMutation {
	m := &FilmMutation{
		config:        c,
		op:            op,
		typ:           TypeFilm,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFilmID sets the ID field of the mutation.
func withFilmID(id int) filmOption {
	return func(m *FilmMutation) {
		var (
			err   error
			once  sync.Once
			value *Film
		)
		m.oldValue = func(ctx context.Context) (*Film, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Film.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFilm sets the old Film of the mutation.
func withFilm(node *Film) filmOption {
	return func(m *FilmMutation) {
		m.oldValue = func(context.Context) (*Film, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FilmMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FilmMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FilmMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FilmMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Film.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDirector sets the "director" field.
func (m *FilmMutation) SetDirector(s string) {
	m.director = &s
}

// Director returns the value of the "director" field in the mutation.
func (m *FilmMutation) Director() (r string, exists bool) {
	v := m.director
	if v == nil {
		return
	}
	return *v, true
}

// OldDirector returns the old "director" field's value of the Film entity.
// If the Film object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilmMutation) OldDirector(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDirector is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDirector requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDirector: %w", err)
	}
	return oldValue.Director, nil
}

// ResetDirector resets all changes to the "director" field.
func (m *FilmMutation) ResetDirector() {
	m.director = nil
}

// SetEpisodeID sets the "episode_id" field.
func (m *FilmMutation) SetEpisodeID(i int) {
	m.episode_id = &i
	m.addepisode_id = nil
}

// EpisodeID returns the value of the "episode_id" field in the mutation.
func (m *FilmMutation) EpisodeID() (r int, exists bool) {
	v := m.episode_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEpisodeID returns the old "episode_id" field's value of the Film entity.
// If the Film object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilmMutation) OldEpisodeID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEpisodeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEpisodeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEpisodeID: %w", err)
	}
	return oldValue.EpisodeID, nil
}

// AddEpisodeID adds i to the "episode_id" field.
func (m *FilmMutation) AddEpisodeID(i int) {
	if m.addepisode_id != nil {
		*m.addepisode_id += i
	} else {
		m.addepisode_id = &i
	}
}

// AddedEpisodeID returns the value that was added to the "episode_id" field in this mutation.
func (m *FilmMutation) AddedEpisodeID() (r int, exists bool) {
	v := m.addepisode_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetEpisodeID resets all changes to the "episode_id" field.
func (m *FilmMutation) ResetEpisodeID() {
	m.episode_id = nil
	m.addepisode_id = nil
}

// SetOpeningCrawl sets the "opening_crawl" field.
func (m *FilmMutation) SetOpeningCrawl(s string) {
	m.opening_crawl = &s
}

// OpeningCrawl returns the value of the "opening_crawl" field in the mutation.
func (m *FilmMutation) OpeningCrawl() (r string, exists bool) {
	v := m.opening_crawl
	if v == nil {
		return
	}
	return *v, true
}

// OldOpeningCrawl returns the old "opening_crawl" field's value of the Film entity.
// If the Film object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilmMutation) OldOpeningCrawl(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOpeningCrawl is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOpeningCrawl requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOpeningCrawl: %w", err)
	}
	return oldValue.OpeningCrawl, nil
}

// ResetOpeningCrawl resets all changes to the "opening_crawl" field.
func (m *FilmMutation) ResetOpeningCrawl() {
	m.opening_crawl = nil
}

// SetProducer sets the "producer" field.
func (m *FilmMutation) SetProducer(s string) {
	m.producer = &s
}

// Producer returns the value of the "producer" field in the mutation.
func (m *FilmMutation) Producer() (r string, exists bool) {
	v := m.producer
	if v == nil {
		return
	}
	return *v, true
}

// OldProducer returns the old "producer" field's value of the Film entity.
// If the Film object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilmMutation) OldProducer(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProducer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProducer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProducer: %w", err)
	}
	return oldValue.Producer, nil
}

// ResetProducer resets all changes to the "producer" field.
func (m *FilmMutation) ResetProducer() {
	m.producer = nil
}

// SetTitle sets the "title" field.
func (m *FilmMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *FilmMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Film entity.
// If the Film object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilmMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *FilmMutation) ResetTitle() {
	m.title = nil
}

// AddHasPersonIDs adds the "has_person" edge to the Person entity by ids.
func (m *FilmMutation) AddHasPersonIDs(ids ...int) {
	if m.has_person == nil {
		m.has_person = make(map[int]struct{})
	}
	for i := range ids {
		m.has_person[ids[i]] = struct{}{}
	}
}

// ClearHasPerson clears the "has_person" edge to the Person entity.
func (m *FilmMutation) ClearHasPerson() {
	m.clearedhas_person = true
}

// HasPersonCleared reports if the "has_person" edge to the Person entity was cleared.
func (m *FilmMutation) HasPersonCleared() bool {
	return m.clearedhas_person
}

// RemoveHasPersonIDs removes the "has_person" edge to the Person entity by IDs.
func (m *FilmMutation) RemoveHasPersonIDs(ids ...int) {
	if m.removedhas_person == nil {
		m.removedhas_person = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.has_person, ids[i])
		m.removedhas_person[ids[i]] = struct{}{}
	}
}

// RemovedHasPerson returns the removed IDs of the "has_person" edge to the Person entity.
func (m *FilmMutation) RemovedHasPersonIDs() (ids []int) {
	for id := range m.removedhas_person {
		ids = append(ids, id)
	}
	return
}

// HasPersonIDs returns the "has_person" edge IDs in the mutation.
func (m *FilmMutation) HasPersonIDs() (ids []int) {
	for id := range m.has_person {
		ids = append(ids, id)
	}
	return
}

// ResetHasPerson resets all changes to the "has_person" edge.
func (m *FilmMutation) ResetHasPerson() {
	m.has_person = nil
	m.clearedhas_person = false
	m.removedhas_person = nil
}

// AddHasPlanetIDs adds the "has_planet" edge to the Planet entity by ids.
func (m *FilmMutation) AddHasPlanetIDs(ids ...int) {
	if m.has_planet == nil {
		m.has_planet = make(map[int]struct{})
	}
	for i := range ids {
		m.has_planet[ids[i]] = struct{}{}
	}
}

// ClearHasPlanet clears the "has_planet" edge to the Planet entity.
func (m *FilmMutation) ClearHasPlanet() {
	m.clearedhas_planet = true
}

// HasPlanetCleared reports if the "has_planet" edge to the Planet entity was cleared.
func (m *FilmMutation) HasPlanetCleared() bool {
	return m.clearedhas_planet
}

// RemoveHasPlanetIDs removes the "has_planet" edge to the Planet entity by IDs.
func (m *FilmMutation) RemoveHasPlanetIDs(ids ...int) {
	if m.removedhas_planet == nil {
		m.removedhas_planet = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.has_planet, ids[i])
		m.removedhas_planet[ids[i]] = struct{}{}
	}
}

// RemovedHasPlanet returns the removed IDs of the "has_planet" edge to the Planet entity.
func (m *FilmMutation) RemovedHasPlanetIDs() (ids []int) {
	for id := range m.removedhas_planet {
		ids = append(ids, id)
	}
	return
}

// HasPlanetIDs returns the "has_planet" edge IDs in the mutation.
func (m *FilmMutation) HasPlanetIDs() (ids []int) {
	for id := range m.has_planet {
		ids = append(ids, id)
	}
	return
}

// ResetHasPlanet resets all changes to the "has_planet" edge.
func (m *FilmMutation) ResetHasPlanet() {
	m.has_planet = nil
	m.clearedhas_planet = false
	m.removedhas_planet = nil
}

// AddHasStarshipIDs adds the "has_starship" edge to the Starship entity by ids.
func (m *FilmMutation) AddHasStarshipIDs(ids ...int) {
	if m.has_starship == nil {
		m.has_starship = make(map[int]struct{})
	}
	for i := range ids {
		m.has_starship[ids[i]] = struct{}{}
	}
}

// ClearHasStarship clears the "has_starship" edge to the Starship entity.
func (m *FilmMutation) ClearHasStarship() {
	m.clearedhas_starship = true
}

// HasStarshipCleared reports if the "has_starship" edge to the Starship entity was cleared.
func (m *FilmMutation) HasStarshipCleared() bool {
	return m.clearedhas_starship
}

// RemoveHasStarshipIDs removes the "has_starship" edge to the Starship entity by IDs.
func (m *FilmMutation) RemoveHasStarshipIDs(ids ...int) {
	if m.removedhas_starship == nil {
		m.removedhas_starship = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.has_starship, ids[i])
		m.removedhas_starship[ids[i]] = struct{}{}
	}
}

// RemovedHasStarship returns the removed IDs of the "has_starship" edge to the Starship entity.
func (m *FilmMutation) RemovedHasStarshipIDs() (ids []int) {
	for id := range m.removedhas_starship {
		ids = append(ids, id)
	}
	return
}

// HasStarshipIDs returns the "has_starship" edge IDs in the mutation.
func (m *FilmMutation) HasStarshipIDs() (ids []int) {
	for id := range m.has_starship {
		ids = append(ids, id)
	}
	return
}

// ResetHasStarship resets all changes to the "has_starship" edge.
func (m *FilmMutation) ResetHasStarship() {
	m.has_starship = nil
	m.clearedhas_starship = false
	m.removedhas_starship = nil
}

// AddHasVehicleIDs adds the "has_vehicle" edge to the Vehicle entity by ids.
func (m *FilmMutation) AddHasVehicleIDs(ids ...int) {
	if m.has_vehicle == nil {
		m.has_vehicle = make(map[int]struct{})
	}
	for i := range ids {
		m.has_vehicle[ids[i]] = struct{}{}
	}
}

// ClearHasVehicle clears the "has_vehicle" edge to the Vehicle entity.
func (m *FilmMutation) ClearHasVehicle() {
	m.clearedhas_vehicle = true
}

// HasVehicleCleared reports if the "has_vehicle" edge to the Vehicle entity was cleared.
func (m *FilmMutation) HasVehicleCleared() bool {
	return m.clearedhas_vehicle
}

// RemoveHasVehicleIDs removes the "has_vehicle" edge to the Vehicle entity by IDs.
func (m *FilmMutation) RemoveHasVehicleIDs(ids ...int) {
	if m.removedhas_vehicle == nil {
		m.removedhas_vehicle = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.has_vehicle, ids[i])
		m.removedhas_vehicle[ids[i]] = struct{}{}
	}
}

// RemovedHasVehicle returns the removed IDs of the "has_vehicle" edge to the Vehicle entity.
func (m *FilmMutation) RemovedHasVehicleIDs() (ids []int) {
	for id := range m.removedhas_vehicle {
		ids = append(ids, id)
	}
	return
}

// HasVehicleIDs returns the "has_vehicle" edge IDs in the mutation.
func (m *FilmMutation) HasVehicleIDs() (ids []int) {
	for id := range m.has_vehicle {
		ids = append(ids, id)
	}
	return
}

// ResetHasVehicle resets all changes to the "has_vehicle" edge.
func (m *FilmMutation) ResetHasVehicle() {
	m.has_vehicle = nil
	m.clearedhas_vehicle = false
	m.removedhas_vehicle = nil
}

// AddHasSpecyIDs adds the "has_species" edge to the Species entity by ids.
func (m *FilmMutation) AddHasSpecyIDs(ids ...int) {
	if m.has_species == nil {
		m.has_species = make(map[int]struct{})
	}
	for i := range ids {
		m.has_species[ids[i]] = struct{}{}
	}
}

// ClearHasSpecies clears the "has_species" edge to the Species entity.
func (m *FilmMutation) ClearHasSpecies() {
	m.clearedhas_species = true
}

// HasSpeciesCleared reports if the "has_species" edge to the Species entity was cleared.
func (m *FilmMutation) HasSpeciesCleared() bool {
	return m.clearedhas_species
}

// RemoveHasSpecyIDs removes the "has_species" edge to the Species entity by IDs.
func (m *FilmMutation) RemoveHasSpecyIDs(ids ...int) {
	if m.removedhas_species == nil {
		m.removedhas_species = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.has_species, ids[i])
		m.removedhas_species[ids[i]] = struct{}{}
	}
}

// RemovedHasSpecies returns the removed IDs of the "has_species" edge to the Species entity.
func (m *FilmMutation) RemovedHasSpeciesIDs() (ids []int) {
	for id := range m.removedhas_species {
		ids = append(ids, id)
	}
	return
}

// HasSpeciesIDs returns the "has_species" edge IDs in the mutation.
func (m *FilmMutation) HasSpeciesIDs() (ids []int) {
	for id := range m.has_species {
		ids = append(ids, id)
	}
	return
}

// ResetHasSpecies resets all changes to the "has_species" edge.
func (m *FilmMutation) ResetHasSpecies() {
	m.has_species = nil
	m.clearedhas_species = false
	m.removedhas_species = nil
}

// Where appends a list predicates to the FilmMutation builder.
func (m *FilmMutation) Where(ps ...predicate.Film) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *FilmMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Film).
func (m *FilmMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FilmMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.director != nil {
		fields = append(fields, film.FieldDirector)
	}
	if m.episode_id != nil {
		fields = append(fields, film.FieldEpisodeID)
	}
	if m.opening_crawl != nil {
		fields = append(fields, film.FieldOpeningCrawl)
	}
	if m.producer != nil {
		fields = append(fields, film.FieldProducer)
	}
	if m.title != nil {
		fields = append(fields, film.FieldTitle)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FilmMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case film.FieldDirector:
		return m.Director()
	case film.FieldEpisodeID:
		return m.EpisodeID()
	case film.FieldOpeningCrawl:
		return m.OpeningCrawl()
	case film.FieldProducer:
		return m.Producer()
	case film.FieldTitle:
		return m.Title()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FilmMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case film.FieldDirector:
		return m.OldDirector(ctx)
	case film.FieldEpisodeID:
		return m.OldEpisodeID(ctx)
	case film.FieldOpeningCrawl:
		return m.OldOpeningCrawl(ctx)
	case film.FieldProducer:
		return m.OldProducer(ctx)
	case film.FieldTitle:
		return m.OldTitle(ctx)
	}
	return nil, fmt.Errorf("unknown Film field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FilmMutation) SetField(name string, value ent.Value) error {
	switch name {
	case film.FieldDirector:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDirector(v)
		return nil
	case film.FieldEpisodeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEpisodeID(v)
		return nil
	case film.FieldOpeningCrawl:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOpeningCrawl(v)
		return nil
	case film.FieldProducer:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProducer(v)
		return nil
	case film.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	}
	return fmt.Errorf("unknown Film field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FilmMutation) AddedFields() []string {
	var fields []string
	if m.addepisode_id != nil {
		fields = append(fields, film.FieldEpisodeID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FilmMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case film.FieldEpisodeID:
		return m.AddedEpisodeID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FilmMutation) AddField(name string, value ent.Value) error {
	switch name {
	case film.FieldEpisodeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEpisodeID(v)
		return nil
	}
	return fmt.Errorf("unknown Film numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FilmMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FilmMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FilmMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Film nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FilmMutation) ResetField(name string) error {
	switch name {
	case film.FieldDirector:
		m.ResetDirector()
		return nil
	case film.FieldEpisodeID:
		m.ResetEpisodeID()
		return nil
	case film.FieldOpeningCrawl:
		m.ResetOpeningCrawl()
		return nil
	case film.FieldProducer:
		m.ResetProducer()
		return nil
	case film.FieldTitle:
		m.ResetTitle()
		return nil
	}
	return fmt.Errorf("unknown Film field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FilmMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.has_person != nil {
		edges = append(edges, film.EdgeHasPerson)
	}
	if m.has_planet != nil {
		edges = append(edges, film.EdgeHasPlanet)
	}
	if m.has_starship != nil {
		edges = append(edges, film.EdgeHasStarship)
	}
	if m.has_vehicle != nil {
		edges = append(edges, film.EdgeHasVehicle)
	}
	if m.has_species != nil {
		edges = append(edges, film.EdgeHasSpecies)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FilmMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case film.EdgeHasPerson:
		ids := make([]ent.Value, 0, len(m.has_person))
		for id := range m.has_person {
			ids = append(ids, id)
		}
		return ids
	case film.EdgeHasPlanet:
		ids := make([]ent.Value, 0, len(m.has_planet))
		for id := range m.has_planet {
			ids = append(ids, id)
		}
		return ids
	case film.EdgeHasStarship:
		ids := make([]ent.Value, 0, len(m.has_starship))
		for id := range m.has_starship {
			ids = append(ids, id)
		}
		return ids
	case film.EdgeHasVehicle:
		ids := make([]ent.Value, 0, len(m.has_vehicle))
		for id := range m.has_vehicle {
			ids = append(ids, id)
		}
		return ids
	case film.EdgeHasSpecies:
		ids := make([]ent.Value, 0, len(m.has_species))
		for id := range m.has_species {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FilmMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedhas_person != nil {
		edges = append(edges, film.EdgeHasPerson)
	}
	if m.removedhas_planet != nil {
		edges = append(edges, film.EdgeHasPlanet)
	}
	if m.removedhas_starship != nil {
		edges = append(edges, film.EdgeHasStarship)
	}
	if m.removedhas_vehicle != nil {
		edges = append(edges, film.EdgeHasVehicle)
	}
	if m.removedhas_species != nil {
		edges = append(edges, film.EdgeHasSpecies)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FilmMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case film.EdgeHasPerson:
		ids := make([]ent.Value, 0, len(m.removedhas_person))
		for id := range m.removedhas_person {
			ids = append(ids, id)
		}
		return ids
	case film.EdgeHasPlanet:
		ids := make([]ent.Value, 0, len(m.removedhas_planet))
		for id := range m.removedhas_planet {
			ids = append(ids, id)
		}
		return ids
	case film.EdgeHasStarship:
		ids := make([]ent.Value, 0, len(m.removedhas_starship))
		for id := range m.removedhas_starship {
			ids = append(ids, id)
		}
		return ids
	case film.EdgeHasVehicle:
		ids := make([]ent.Value, 0, len(m.removedhas_vehicle))
		for id := range m.removedhas_vehicle {
			ids = append(ids, id)
		}
		return ids
	case film.EdgeHasSpecies:
		ids := make([]ent.Value, 0, len(m.removedhas_species))
		for id := range m.removedhas_species {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FilmMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedhas_person {
		edges = append(edges, film.EdgeHasPerson)
	}
	if m.clearedhas_planet {
		edges = append(edges, film.EdgeHasPlanet)
	}
	if m.clearedhas_starship {
		edges = append(edges, film.EdgeHasStarship)
	}
	if m.clearedhas_vehicle {
		edges = append(edges, film.EdgeHasVehicle)
	}
	if m.clearedhas_species {
		edges = append(edges, film.EdgeHasSpecies)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FilmMutation) EdgeCleared(name string) bool {
	switch name {
	case film.EdgeHasPerson:
		return m.clearedhas_person
	case film.EdgeHasPlanet:
		return m.clearedhas_planet
	case film.EdgeHasStarship:
		return m.clearedhas_starship
	case film.EdgeHasVehicle:
		return m.clearedhas_vehicle
	case film.EdgeHasSpecies:
		return m.clearedhas_species
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FilmMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Film unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FilmMutation) ResetEdge(name string) error {
	switch name {
	case film.EdgeHasPerson:
		m.ResetHasPerson()
		return nil
	case film.EdgeHasPlanet:
		m.ResetHasPlanet()
		return nil
	case film.EdgeHasStarship:
		m.ResetHasStarship()
		return nil
	case film.EdgeHasVehicle:
		m.ResetHasVehicle()
		return nil
	case film.EdgeHasSpecies:
		m.ResetHasSpecies()
		return nil
	}
	return fmt.Errorf("unknown Film edge %s", name)
}

// PersonMutation represents an operation that mutates the Person nodes in the graph.
type PersonMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	birth_year              *string
	eye_color               *string
	gender                  *string
	hair_color              *string
	height                  *int
	addheight               *int
	mass                    *float64
	addmass                 *float64
	name                    *string
	skin_color              *string
	clearedFields           map[string]struct{}
	piloted_starship        map[int]struct{}
	removedpiloted_starship map[int]struct{}
	clearedpiloted_starship bool
	piloted_vehicle         map[int]struct{}
	removedpiloted_vehicle  map[int]struct{}
	clearedpiloted_vehicle  bool
	is_of_type              map[int]struct{}
	removedis_of_type       map[int]struct{}
	clearedis_of_type       bool
	appeared_in             map[int]struct{}
	removedappeared_in      map[int]struct{}
	clearedappeared_in      bool
	from_planet             map[int]struct{}
	removedfrom_planet      map[int]struct{}
	clearedfrom_planet      bool
	done                    bool
	oldValue                func(context.Context) (*Person, error)
	predicates              []predicate.Person
}

var _ ent.Mutation = (*PersonMutation)(nil)

// personOption allows management of the mutation configuration using functional options.
type personOption func(*PersonMutation)

// newPersonMutation creates new mutation for the Person entity.
func newPersonMutation(c config, op Op, opts ...personOption) *PersonMutation {
	m := &PersonMutation{
		config:        c,
		op:            op,
		typ:           TypePerson,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPersonID sets the ID field of the mutation.
func withPersonID(id int) personOption {
	return func(m *PersonMutation) {
		var (
			err   error
			once  sync.Once
			value *Person
		)
		m.oldValue = func(ctx context.Context) (*Person, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Person.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPerson sets the old Person of the mutation.
func withPerson(node *Person) personOption {
	return func(m *PersonMutation) {
		m.oldValue = func(context.Context) (*Person, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PersonMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PersonMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PersonMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PersonMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Person.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBirthYear sets the "birth_year" field.
func (m *PersonMutation) SetBirthYear(s string) {
	m.birth_year = &s
}

// BirthYear returns the value of the "birth_year" field in the mutation.
func (m *PersonMutation) BirthYear() (r string, exists bool) {
	v := m.birth_year
	if v == nil {
		return
	}
	return *v, true
}

// OldBirthYear returns the old "birth_year" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldBirthYear(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBirthYear is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBirthYear requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBirthYear: %w", err)
	}
	return oldValue.BirthYear, nil
}

// ResetBirthYear resets all changes to the "birth_year" field.
func (m *PersonMutation) ResetBirthYear() {
	m.birth_year = nil
}

// SetEyeColor sets the "eye_color" field.
func (m *PersonMutation) SetEyeColor(s string) {
	m.eye_color = &s
}

// EyeColor returns the value of the "eye_color" field in the mutation.
func (m *PersonMutation) EyeColor() (r string, exists bool) {
	v := m.eye_color
	if v == nil {
		return
	}
	return *v, true
}

// OldEyeColor returns the old "eye_color" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldEyeColor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEyeColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEyeColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEyeColor: %w", err)
	}
	return oldValue.EyeColor, nil
}

// ResetEyeColor resets all changes to the "eye_color" field.
func (m *PersonMutation) ResetEyeColor() {
	m.eye_color = nil
}

// SetGender sets the "gender" field.
func (m *PersonMutation) SetGender(s string) {
	m.gender = &s
}

// Gender returns the value of the "gender" field in the mutation.
func (m *PersonMutation) Gender() (r string, exists bool) {
	v := m.gender
	if v == nil {
		return
	}
	return *v, true
}

// OldGender returns the old "gender" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldGender(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGender is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGender requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGender: %w", err)
	}
	return oldValue.Gender, nil
}

// ResetGender resets all changes to the "gender" field.
func (m *PersonMutation) ResetGender() {
	m.gender = nil
}

// SetHairColor sets the "hair_color" field.
func (m *PersonMutation) SetHairColor(s string) {
	m.hair_color = &s
}

// HairColor returns the value of the "hair_color" field in the mutation.
func (m *PersonMutation) HairColor() (r string, exists bool) {
	v := m.hair_color
	if v == nil {
		return
	}
	return *v, true
}

// OldHairColor returns the old "hair_color" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldHairColor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHairColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHairColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHairColor: %w", err)
	}
	return oldValue.HairColor, nil
}

// ResetHairColor resets all changes to the "hair_color" field.
func (m *PersonMutation) ResetHairColor() {
	m.hair_color = nil
}

// SetHeight sets the "height" field.
func (m *PersonMutation) SetHeight(i int) {
	m.height = &i
	m.addheight = nil
}

// Height returns the value of the "height" field in the mutation.
func (m *PersonMutation) Height() (r int, exists bool) {
	v := m.height
	if v == nil {
		return
	}
	return *v, true
}

// OldHeight returns the old "height" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldHeight(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHeight: %w", err)
	}
	return oldValue.Height, nil
}

// AddHeight adds i to the "height" field.
func (m *PersonMutation) AddHeight(i int) {
	if m.addheight != nil {
		*m.addheight += i
	} else {
		m.addheight = &i
	}
}

// AddedHeight returns the value that was added to the "height" field in this mutation.
func (m *PersonMutation) AddedHeight() (r int, exists bool) {
	v := m.addheight
	if v == nil {
		return
	}
	return *v, true
}

// ResetHeight resets all changes to the "height" field.
func (m *PersonMutation) ResetHeight() {
	m.height = nil
	m.addheight = nil
}

// SetMass sets the "mass" field.
func (m *PersonMutation) SetMass(f float64) {
	m.mass = &f
	m.addmass = nil
}

// Mass returns the value of the "mass" field in the mutation.
func (m *PersonMutation) Mass() (r float64, exists bool) {
	v := m.mass
	if v == nil {
		return
	}
	return *v, true
}

// OldMass returns the old "mass" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldMass(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMass is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMass requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMass: %w", err)
	}
	return oldValue.Mass, nil
}

// AddMass adds f to the "mass" field.
func (m *PersonMutation) AddMass(f float64) {
	if m.addmass != nil {
		*m.addmass += f
	} else {
		m.addmass = &f
	}
}

// AddedMass returns the value that was added to the "mass" field in this mutation.
func (m *PersonMutation) AddedMass() (r float64, exists bool) {
	v := m.addmass
	if v == nil {
		return
	}
	return *v, true
}

// ClearMass clears the value of the "mass" field.
func (m *PersonMutation) ClearMass() {
	m.mass = nil
	m.addmass = nil
	m.clearedFields[person.FieldMass] = struct{}{}
}

// MassCleared returns if the "mass" field was cleared in this mutation.
func (m *PersonMutation) MassCleared() bool {
	_, ok := m.clearedFields[person.FieldMass]
	return ok
}

// ResetMass resets all changes to the "mass" field.
func (m *PersonMutation) ResetMass() {
	m.mass = nil
	m.addmass = nil
	delete(m.clearedFields, person.FieldMass)
}

// SetName sets the "name" field.
func (m *PersonMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PersonMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PersonMutation) ResetName() {
	m.name = nil
}

// SetSkinColor sets the "skin_color" field.
func (m *PersonMutation) SetSkinColor(s string) {
	m.skin_color = &s
}

// SkinColor returns the value of the "skin_color" field in the mutation.
func (m *PersonMutation) SkinColor() (r string, exists bool) {
	v := m.skin_color
	if v == nil {
		return
	}
	return *v, true
}

// OldSkinColor returns the old "skin_color" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldSkinColor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSkinColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSkinColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSkinColor: %w", err)
	}
	return oldValue.SkinColor, nil
}

// ResetSkinColor resets all changes to the "skin_color" field.
func (m *PersonMutation) ResetSkinColor() {
	m.skin_color = nil
}

// AddPilotedStarshipIDs adds the "piloted_starship" edge to the Starship entity by ids.
func (m *PersonMutation) AddPilotedStarshipIDs(ids ...int) {
	if m.piloted_starship == nil {
		m.piloted_starship = make(map[int]struct{})
	}
	for i := range ids {
		m.piloted_starship[ids[i]] = struct{}{}
	}
}

// ClearPilotedStarship clears the "piloted_starship" edge to the Starship entity.
func (m *PersonMutation) ClearPilotedStarship() {
	m.clearedpiloted_starship = true
}

// PilotedStarshipCleared reports if the "piloted_starship" edge to the Starship entity was cleared.
func (m *PersonMutation) PilotedStarshipCleared() bool {
	return m.clearedpiloted_starship
}

// RemovePilotedStarshipIDs removes the "piloted_starship" edge to the Starship entity by IDs.
func (m *PersonMutation) RemovePilotedStarshipIDs(ids ...int) {
	if m.removedpiloted_starship == nil {
		m.removedpiloted_starship = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.piloted_starship, ids[i])
		m.removedpiloted_starship[ids[i]] = struct{}{}
	}
}

// RemovedPilotedStarship returns the removed IDs of the "piloted_starship" edge to the Starship entity.
func (m *PersonMutation) RemovedPilotedStarshipIDs() (ids []int) {
	for id := range m.removedpiloted_starship {
		ids = append(ids, id)
	}
	return
}

// PilotedStarshipIDs returns the "piloted_starship" edge IDs in the mutation.
func (m *PersonMutation) PilotedStarshipIDs() (ids []int) {
	for id := range m.piloted_starship {
		ids = append(ids, id)
	}
	return
}

// ResetPilotedStarship resets all changes to the "piloted_starship" edge.
func (m *PersonMutation) ResetPilotedStarship() {
	m.piloted_starship = nil
	m.clearedpiloted_starship = false
	m.removedpiloted_starship = nil
}

// AddPilotedVehicleIDs adds the "piloted_vehicle" edge to the Vehicle entity by ids.
func (m *PersonMutation) AddPilotedVehicleIDs(ids ...int) {
	if m.piloted_vehicle == nil {
		m.piloted_vehicle = make(map[int]struct{})
	}
	for i := range ids {
		m.piloted_vehicle[ids[i]] = struct{}{}
	}
}

// ClearPilotedVehicle clears the "piloted_vehicle" edge to the Vehicle entity.
func (m *PersonMutation) ClearPilotedVehicle() {
	m.clearedpiloted_vehicle = true
}

// PilotedVehicleCleared reports if the "piloted_vehicle" edge to the Vehicle entity was cleared.
func (m *PersonMutation) PilotedVehicleCleared() bool {
	return m.clearedpiloted_vehicle
}

// RemovePilotedVehicleIDs removes the "piloted_vehicle" edge to the Vehicle entity by IDs.
func (m *PersonMutation) RemovePilotedVehicleIDs(ids ...int) {
	if m.removedpiloted_vehicle == nil {
		m.removedpiloted_vehicle = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.piloted_vehicle, ids[i])
		m.removedpiloted_vehicle[ids[i]] = struct{}{}
	}
}

// RemovedPilotedVehicle returns the removed IDs of the "piloted_vehicle" edge to the Vehicle entity.
func (m *PersonMutation) RemovedPilotedVehicleIDs() (ids []int) {
	for id := range m.removedpiloted_vehicle {
		ids = append(ids, id)
	}
	return
}

// PilotedVehicleIDs returns the "piloted_vehicle" edge IDs in the mutation.
func (m *PersonMutation) PilotedVehicleIDs() (ids []int) {
	for id := range m.piloted_vehicle {
		ids = append(ids, id)
	}
	return
}

// ResetPilotedVehicle resets all changes to the "piloted_vehicle" edge.
func (m *PersonMutation) ResetPilotedVehicle() {
	m.piloted_vehicle = nil
	m.clearedpiloted_vehicle = false
	m.removedpiloted_vehicle = nil
}

// AddIsOfTypeIDs adds the "is_of_type" edge to the Species entity by ids.
func (m *PersonMutation) AddIsOfTypeIDs(ids ...int) {
	if m.is_of_type == nil {
		m.is_of_type = make(map[int]struct{})
	}
	for i := range ids {
		m.is_of_type[ids[i]] = struct{}{}
	}
}

// ClearIsOfType clears the "is_of_type" edge to the Species entity.
func (m *PersonMutation) ClearIsOfType() {
	m.clearedis_of_type = true
}

// IsOfTypeCleared reports if the "is_of_type" edge to the Species entity was cleared.
func (m *PersonMutation) IsOfTypeCleared() bool {
	return m.clearedis_of_type
}

// RemoveIsOfTypeIDs removes the "is_of_type" edge to the Species entity by IDs.
func (m *PersonMutation) RemoveIsOfTypeIDs(ids ...int) {
	if m.removedis_of_type == nil {
		m.removedis_of_type = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.is_of_type, ids[i])
		m.removedis_of_type[ids[i]] = struct{}{}
	}
}

// RemovedIsOfType returns the removed IDs of the "is_of_type" edge to the Species entity.
func (m *PersonMutation) RemovedIsOfTypeIDs() (ids []int) {
	for id := range m.removedis_of_type {
		ids = append(ids, id)
	}
	return
}

// IsOfTypeIDs returns the "is_of_type" edge IDs in the mutation.
func (m *PersonMutation) IsOfTypeIDs() (ids []int) {
	for id := range m.is_of_type {
		ids = append(ids, id)
	}
	return
}

// ResetIsOfType resets all changes to the "is_of_type" edge.
func (m *PersonMutation) ResetIsOfType() {
	m.is_of_type = nil
	m.clearedis_of_type = false
	m.removedis_of_type = nil
}

// AddAppearedInIDs adds the "appeared_in" edge to the Film entity by ids.
func (m *PersonMutation) AddAppearedInIDs(ids ...int) {
	if m.appeared_in == nil {
		m.appeared_in = make(map[int]struct{})
	}
	for i := range ids {
		m.appeared_in[ids[i]] = struct{}{}
	}
}

// ClearAppearedIn clears the "appeared_in" edge to the Film entity.
func (m *PersonMutation) ClearAppearedIn() {
	m.clearedappeared_in = true
}

// AppearedInCleared reports if the "appeared_in" edge to the Film entity was cleared.
func (m *PersonMutation) AppearedInCleared() bool {
	return m.clearedappeared_in
}

// RemoveAppearedInIDs removes the "appeared_in" edge to the Film entity by IDs.
func (m *PersonMutation) RemoveAppearedInIDs(ids ...int) {
	if m.removedappeared_in == nil {
		m.removedappeared_in = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.appeared_in, ids[i])
		m.removedappeared_in[ids[i]] = struct{}{}
	}
}

// RemovedAppearedIn returns the removed IDs of the "appeared_in" edge to the Film entity.
func (m *PersonMutation) RemovedAppearedInIDs() (ids []int) {
	for id := range m.removedappeared_in {
		ids = append(ids, id)
	}
	return
}

// AppearedInIDs returns the "appeared_in" edge IDs in the mutation.
func (m *PersonMutation) AppearedInIDs() (ids []int) {
	for id := range m.appeared_in {
		ids = append(ids, id)
	}
	return
}

// ResetAppearedIn resets all changes to the "appeared_in" edge.
func (m *PersonMutation) ResetAppearedIn() {
	m.appeared_in = nil
	m.clearedappeared_in = false
	m.removedappeared_in = nil
}

// AddFromPlanetIDs adds the "from_planet" edge to the Planet entity by ids.
func (m *PersonMutation) AddFromPlanetIDs(ids ...int) {
	if m.from_planet == nil {
		m.from_planet = make(map[int]struct{})
	}
	for i := range ids {
		m.from_planet[ids[i]] = struct{}{}
	}
}

// ClearFromPlanet clears the "from_planet" edge to the Planet entity.
func (m *PersonMutation) ClearFromPlanet() {
	m.clearedfrom_planet = true
}

// FromPlanetCleared reports if the "from_planet" edge to the Planet entity was cleared.
func (m *PersonMutation) FromPlanetCleared() bool {
	return m.clearedfrom_planet
}

// RemoveFromPlanetIDs removes the "from_planet" edge to the Planet entity by IDs.
func (m *PersonMutation) RemoveFromPlanetIDs(ids ...int) {
	if m.removedfrom_planet == nil {
		m.removedfrom_planet = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.from_planet, ids[i])
		m.removedfrom_planet[ids[i]] = struct{}{}
	}
}

// RemovedFromPlanet returns the removed IDs of the "from_planet" edge to the Planet entity.
func (m *PersonMutation) RemovedFromPlanetIDs() (ids []int) {
	for id := range m.removedfrom_planet {
		ids = append(ids, id)
	}
	return
}

// FromPlanetIDs returns the "from_planet" edge IDs in the mutation.
func (m *PersonMutation) FromPlanetIDs() (ids []int) {
	for id := range m.from_planet {
		ids = append(ids, id)
	}
	return
}

// ResetFromPlanet resets all changes to the "from_planet" edge.
func (m *PersonMutation) ResetFromPlanet() {
	m.from_planet = nil
	m.clearedfrom_planet = false
	m.removedfrom_planet = nil
}

// Where appends a list predicates to the PersonMutation builder.
func (m *PersonMutation) Where(ps ...predicate.Person) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *PersonMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Person).
func (m *PersonMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PersonMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.birth_year != nil {
		fields = append(fields, person.FieldBirthYear)
	}
	if m.eye_color != nil {
		fields = append(fields, person.FieldEyeColor)
	}
	if m.gender != nil {
		fields = append(fields, person.FieldGender)
	}
	if m.hair_color != nil {
		fields = append(fields, person.FieldHairColor)
	}
	if m.height != nil {
		fields = append(fields, person.FieldHeight)
	}
	if m.mass != nil {
		fields = append(fields, person.FieldMass)
	}
	if m.name != nil {
		fields = append(fields, person.FieldName)
	}
	if m.skin_color != nil {
		fields = append(fields, person.FieldSkinColor)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PersonMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case person.FieldBirthYear:
		return m.BirthYear()
	case person.FieldEyeColor:
		return m.EyeColor()
	case person.FieldGender:
		return m.Gender()
	case person.FieldHairColor:
		return m.HairColor()
	case person.FieldHeight:
		return m.Height()
	case person.FieldMass:
		return m.Mass()
	case person.FieldName:
		return m.Name()
	case person.FieldSkinColor:
		return m.SkinColor()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PersonMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case person.FieldBirthYear:
		return m.OldBirthYear(ctx)
	case person.FieldEyeColor:
		return m.OldEyeColor(ctx)
	case person.FieldGender:
		return m.OldGender(ctx)
	case person.FieldHairColor:
		return m.OldHairColor(ctx)
	case person.FieldHeight:
		return m.OldHeight(ctx)
	case person.FieldMass:
		return m.OldMass(ctx)
	case person.FieldName:
		return m.OldName(ctx)
	case person.FieldSkinColor:
		return m.OldSkinColor(ctx)
	}
	return nil, fmt.Errorf("unknown Person field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PersonMutation) SetField(name string, value ent.Value) error {
	switch name {
	case person.FieldBirthYear:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBirthYear(v)
		return nil
	case person.FieldEyeColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEyeColor(v)
		return nil
	case person.FieldGender:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGender(v)
		return nil
	case person.FieldHairColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHairColor(v)
		return nil
	case person.FieldHeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHeight(v)
		return nil
	case person.FieldMass:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMass(v)
		return nil
	case person.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case person.FieldSkinColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSkinColor(v)
		return nil
	}
	return fmt.Errorf("unknown Person field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PersonMutation) AddedFields() []string {
	var fields []string
	if m.addheight != nil {
		fields = append(fields, person.FieldHeight)
	}
	if m.addmass != nil {
		fields = append(fields, person.FieldMass)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PersonMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case person.FieldHeight:
		return m.AddedHeight()
	case person.FieldMass:
		return m.AddedMass()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PersonMutation) AddField(name string, value ent.Value) error {
	switch name {
	case person.FieldHeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHeight(v)
		return nil
	case person.FieldMass:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMass(v)
		return nil
	}
	return fmt.Errorf("unknown Person numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PersonMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(person.FieldMass) {
		fields = append(fields, person.FieldMass)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PersonMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PersonMutation) ClearField(name string) error {
	switch name {
	case person.FieldMass:
		m.ClearMass()
		return nil
	}
	return fmt.Errorf("unknown Person nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PersonMutation) ResetField(name string) error {
	switch name {
	case person.FieldBirthYear:
		m.ResetBirthYear()
		return nil
	case person.FieldEyeColor:
		m.ResetEyeColor()
		return nil
	case person.FieldGender:
		m.ResetGender()
		return nil
	case person.FieldHairColor:
		m.ResetHairColor()
		return nil
	case person.FieldHeight:
		m.ResetHeight()
		return nil
	case person.FieldMass:
		m.ResetMass()
		return nil
	case person.FieldName:
		m.ResetName()
		return nil
	case person.FieldSkinColor:
		m.ResetSkinColor()
		return nil
	}
	return fmt.Errorf("unknown Person field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PersonMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.piloted_starship != nil {
		edges = append(edges, person.EdgePilotedStarship)
	}
	if m.piloted_vehicle != nil {
		edges = append(edges, person.EdgePilotedVehicle)
	}
	if m.is_of_type != nil {
		edges = append(edges, person.EdgeIsOfType)
	}
	if m.appeared_in != nil {
		edges = append(edges, person.EdgeAppearedIn)
	}
	if m.from_planet != nil {
		edges = append(edges, person.EdgeFromPlanet)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PersonMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case person.EdgePilotedStarship:
		ids := make([]ent.Value, 0, len(m.piloted_starship))
		for id := range m.piloted_starship {
			ids = append(ids, id)
		}
		return ids
	case person.EdgePilotedVehicle:
		ids := make([]ent.Value, 0, len(m.piloted_vehicle))
		for id := range m.piloted_vehicle {
			ids = append(ids, id)
		}
		return ids
	case person.EdgeIsOfType:
		ids := make([]ent.Value, 0, len(m.is_of_type))
		for id := range m.is_of_type {
			ids = append(ids, id)
		}
		return ids
	case person.EdgeAppearedIn:
		ids := make([]ent.Value, 0, len(m.appeared_in))
		for id := range m.appeared_in {
			ids = append(ids, id)
		}
		return ids
	case person.EdgeFromPlanet:
		ids := make([]ent.Value, 0, len(m.from_planet))
		for id := range m.from_planet {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PersonMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedpiloted_starship != nil {
		edges = append(edges, person.EdgePilotedStarship)
	}
	if m.removedpiloted_vehicle != nil {
		edges = append(edges, person.EdgePilotedVehicle)
	}
	if m.removedis_of_type != nil {
		edges = append(edges, person.EdgeIsOfType)
	}
	if m.removedappeared_in != nil {
		edges = append(edges, person.EdgeAppearedIn)
	}
	if m.removedfrom_planet != nil {
		edges = append(edges, person.EdgeFromPlanet)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PersonMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case person.EdgePilotedStarship:
		ids := make([]ent.Value, 0, len(m.removedpiloted_starship))
		for id := range m.removedpiloted_starship {
			ids = append(ids, id)
		}
		return ids
	case person.EdgePilotedVehicle:
		ids := make([]ent.Value, 0, len(m.removedpiloted_vehicle))
		for id := range m.removedpiloted_vehicle {
			ids = append(ids, id)
		}
		return ids
	case person.EdgeIsOfType:
		ids := make([]ent.Value, 0, len(m.removedis_of_type))
		for id := range m.removedis_of_type {
			ids = append(ids, id)
		}
		return ids
	case person.EdgeAppearedIn:
		ids := make([]ent.Value, 0, len(m.removedappeared_in))
		for id := range m.removedappeared_in {
			ids = append(ids, id)
		}
		return ids
	case person.EdgeFromPlanet:
		ids := make([]ent.Value, 0, len(m.removedfrom_planet))
		for id := range m.removedfrom_planet {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PersonMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedpiloted_starship {
		edges = append(edges, person.EdgePilotedStarship)
	}
	if m.clearedpiloted_vehicle {
		edges = append(edges, person.EdgePilotedVehicle)
	}
	if m.clearedis_of_type {
		edges = append(edges, person.EdgeIsOfType)
	}
	if m.clearedappeared_in {
		edges = append(edges, person.EdgeAppearedIn)
	}
	if m.clearedfrom_planet {
		edges = append(edges, person.EdgeFromPlanet)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PersonMutation) EdgeCleared(name string) bool {
	switch name {
	case person.EdgePilotedStarship:
		return m.clearedpiloted_starship
	case person.EdgePilotedVehicle:
		return m.clearedpiloted_vehicle
	case person.EdgeIsOfType:
		return m.clearedis_of_type
	case person.EdgeAppearedIn:
		return m.clearedappeared_in
	case person.EdgeFromPlanet:
		return m.clearedfrom_planet
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PersonMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Person unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PersonMutation) ResetEdge(name string) error {
	switch name {
	case person.EdgePilotedStarship:
		m.ResetPilotedStarship()
		return nil
	case person.EdgePilotedVehicle:
		m.ResetPilotedVehicle()
		return nil
	case person.EdgeIsOfType:
		m.ResetIsOfType()
		return nil
	case person.EdgeAppearedIn:
		m.ResetAppearedIn()
		return nil
	case person.EdgeFromPlanet:
		m.ResetFromPlanet()
		return nil
	}
	return fmt.Errorf("unknown Person edge %s", name)
}

// PlanetMutation represents an operation that mutates the Planet nodes in the graph.
type PlanetMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	climate            *string
	diameter           *int
	adddiameter        *int
	gravity            *string
	name               *string
	orbital_period     *string
	population         *int
	addpopulation      *int
	rotation_period    *string
	surface_water      *string
	terrain            *string
	clearedFields      map[string]struct{}
	home_to            map[int]struct{}
	removedhome_to     map[int]struct{}
	clearedhome_to     bool
	appeared_in        map[int]struct{}
	removedappeared_in map[int]struct{}
	clearedappeared_in bool
	origin_of          map[int]struct{}
	removedorigin_of   map[int]struct{}
	clearedorigin_of   bool
	done               bool
	oldValue           func(context.Context) (*Planet, error)
	predicates         []predicate.Planet
}

var _ ent.Mutation = (*PlanetMutation)(nil)

// planetOption allows management of the mutation configuration using functional options.
type planetOption func(*PlanetMutation)

// newPlanetMutation creates new mutation for the Planet entity.
func newPlanetMutation(c config, op Op, opts ...planetOption) *PlanetMutation {
	m := &PlanetMutation{
		config:        c,
		op:            op,
		typ:           TypePlanet,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPlanetID sets the ID field of the mutation.
func withPlanetID(id int) planetOption {
	return func(m *PlanetMutation) {
		var (
			err   error
			once  sync.Once
			value *Planet
		)
		m.oldValue = func(ctx context.Context) (*Planet, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Planet.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPlanet sets the old Planet of the mutation.
func withPlanet(node *Planet) planetOption {
	return func(m *PlanetMutation) {
		m.oldValue = func(context.Context) (*Planet, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PlanetMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PlanetMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PlanetMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PlanetMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Planet.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetClimate sets the "climate" field.
func (m *PlanetMutation) SetClimate(s string) {
	m.climate = &s
}

// Climate returns the value of the "climate" field in the mutation.
func (m *PlanetMutation) Climate() (r string, exists bool) {
	v := m.climate
	if v == nil {
		return
	}
	return *v, true
}

// OldClimate returns the old "climate" field's value of the Planet entity.
// If the Planet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanetMutation) OldClimate(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClimate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClimate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClimate: %w", err)
	}
	return oldValue.Climate, nil
}

// ResetClimate resets all changes to the "climate" field.
func (m *PlanetMutation) ResetClimate() {
	m.climate = nil
}

// SetDiameter sets the "diameter" field.
func (m *PlanetMutation) SetDiameter(i int) {
	m.diameter = &i
	m.adddiameter = nil
}

// Diameter returns the value of the "diameter" field in the mutation.
func (m *PlanetMutation) Diameter() (r int, exists bool) {
	v := m.diameter
	if v == nil {
		return
	}
	return *v, true
}

// OldDiameter returns the old "diameter" field's value of the Planet entity.
// If the Planet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanetMutation) OldDiameter(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDiameter is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDiameter requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiameter: %w", err)
	}
	return oldValue.Diameter, nil
}

// AddDiameter adds i to the "diameter" field.
func (m *PlanetMutation) AddDiameter(i int) {
	if m.adddiameter != nil {
		*m.adddiameter += i
	} else {
		m.adddiameter = &i
	}
}

// AddedDiameter returns the value that was added to the "diameter" field in this mutation.
func (m *PlanetMutation) AddedDiameter() (r int, exists bool) {
	v := m.adddiameter
	if v == nil {
		return
	}
	return *v, true
}

// ClearDiameter clears the value of the "diameter" field.
func (m *PlanetMutation) ClearDiameter() {
	m.diameter = nil
	m.adddiameter = nil
	m.clearedFields[planet.FieldDiameter] = struct{}{}
}

// DiameterCleared returns if the "diameter" field was cleared in this mutation.
func (m *PlanetMutation) DiameterCleared() bool {
	_, ok := m.clearedFields[planet.FieldDiameter]
	return ok
}

// ResetDiameter resets all changes to the "diameter" field.
func (m *PlanetMutation) ResetDiameter() {
	m.diameter = nil
	m.adddiameter = nil
	delete(m.clearedFields, planet.FieldDiameter)
}

// SetGravity sets the "gravity" field.
func (m *PlanetMutation) SetGravity(s string) {
	m.gravity = &s
}

// Gravity returns the value of the "gravity" field in the mutation.
func (m *PlanetMutation) Gravity() (r string, exists bool) {
	v := m.gravity
	if v == nil {
		return
	}
	return *v, true
}

// OldGravity returns the old "gravity" field's value of the Planet entity.
// If the Planet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanetMutation) OldGravity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGravity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGravity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGravity: %w", err)
	}
	return oldValue.Gravity, nil
}

// ResetGravity resets all changes to the "gravity" field.
func (m *PlanetMutation) ResetGravity() {
	m.gravity = nil
}

// SetName sets the "name" field.
func (m *PlanetMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PlanetMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Planet entity.
// If the Planet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanetMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PlanetMutation) ResetName() {
	m.name = nil
}

// SetOrbitalPeriod sets the "orbital_period" field.
func (m *PlanetMutation) SetOrbitalPeriod(s string) {
	m.orbital_period = &s
}

// OrbitalPeriod returns the value of the "orbital_period" field in the mutation.
func (m *PlanetMutation) OrbitalPeriod() (r string, exists bool) {
	v := m.orbital_period
	if v == nil {
		return
	}
	return *v, true
}

// OldOrbitalPeriod returns the old "orbital_period" field's value of the Planet entity.
// If the Planet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanetMutation) OldOrbitalPeriod(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrbitalPeriod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrbitalPeriod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrbitalPeriod: %w", err)
	}
	return oldValue.OrbitalPeriod, nil
}

// ResetOrbitalPeriod resets all changes to the "orbital_period" field.
func (m *PlanetMutation) ResetOrbitalPeriod() {
	m.orbital_period = nil
}

// SetPopulation sets the "population" field.
func (m *PlanetMutation) SetPopulation(i int) {
	m.population = &i
	m.addpopulation = nil
}

// Population returns the value of the "population" field in the mutation.
func (m *PlanetMutation) Population() (r int, exists bool) {
	v := m.population
	if v == nil {
		return
	}
	return *v, true
}

// OldPopulation returns the old "population" field's value of the Planet entity.
// If the Planet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanetMutation) OldPopulation(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPopulation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPopulation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPopulation: %w", err)
	}
	return oldValue.Population, nil
}

// AddPopulation adds i to the "population" field.
func (m *PlanetMutation) AddPopulation(i int) {
	if m.addpopulation != nil {
		*m.addpopulation += i
	} else {
		m.addpopulation = &i
	}
}

// AddedPopulation returns the value that was added to the "population" field in this mutation.
func (m *PlanetMutation) AddedPopulation() (r int, exists bool) {
	v := m.addpopulation
	if v == nil {
		return
	}
	return *v, true
}

// ClearPopulation clears the value of the "population" field.
func (m *PlanetMutation) ClearPopulation() {
	m.population = nil
	m.addpopulation = nil
	m.clearedFields[planet.FieldPopulation] = struct{}{}
}

// PopulationCleared returns if the "population" field was cleared in this mutation.
func (m *PlanetMutation) PopulationCleared() bool {
	_, ok := m.clearedFields[planet.FieldPopulation]
	return ok
}

// ResetPopulation resets all changes to the "population" field.
func (m *PlanetMutation) ResetPopulation() {
	m.population = nil
	m.addpopulation = nil
	delete(m.clearedFields, planet.FieldPopulation)
}

// SetRotationPeriod sets the "rotation_period" field.
func (m *PlanetMutation) SetRotationPeriod(s string) {
	m.rotation_period = &s
}

// RotationPeriod returns the value of the "rotation_period" field in the mutation.
func (m *PlanetMutation) RotationPeriod() (r string, exists bool) {
	v := m.rotation_period
	if v == nil {
		return
	}
	return *v, true
}

// OldRotationPeriod returns the old "rotation_period" field's value of the Planet entity.
// If the Planet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanetMutation) OldRotationPeriod(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRotationPeriod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRotationPeriod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRotationPeriod: %w", err)
	}
	return oldValue.RotationPeriod, nil
}

// ResetRotationPeriod resets all changes to the "rotation_period" field.
func (m *PlanetMutation) ResetRotationPeriod() {
	m.rotation_period = nil
}

// SetSurfaceWater sets the "surface_water" field.
func (m *PlanetMutation) SetSurfaceWater(s string) {
	m.surface_water = &s
}

// SurfaceWater returns the value of the "surface_water" field in the mutation.
func (m *PlanetMutation) SurfaceWater() (r string, exists bool) {
	v := m.surface_water
	if v == nil {
		return
	}
	return *v, true
}

// OldSurfaceWater returns the old "surface_water" field's value of the Planet entity.
// If the Planet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanetMutation) OldSurfaceWater(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSurfaceWater is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSurfaceWater requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSurfaceWater: %w", err)
	}
	return oldValue.SurfaceWater, nil
}

// ResetSurfaceWater resets all changes to the "surface_water" field.
func (m *PlanetMutation) ResetSurfaceWater() {
	m.surface_water = nil
}

// SetTerrain sets the "terrain" field.
func (m *PlanetMutation) SetTerrain(s string) {
	m.terrain = &s
}

// Terrain returns the value of the "terrain" field in the mutation.
func (m *PlanetMutation) Terrain() (r string, exists bool) {
	v := m.terrain
	if v == nil {
		return
	}
	return *v, true
}

// OldTerrain returns the old "terrain" field's value of the Planet entity.
// If the Planet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanetMutation) OldTerrain(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTerrain is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTerrain requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTerrain: %w", err)
	}
	return oldValue.Terrain, nil
}

// ResetTerrain resets all changes to the "terrain" field.
func (m *PlanetMutation) ResetTerrain() {
	m.terrain = nil
}

// AddHomeToIDs adds the "home_to" edge to the Person entity by ids.
func (m *PlanetMutation) AddHomeToIDs(ids ...int) {
	if m.home_to == nil {
		m.home_to = make(map[int]struct{})
	}
	for i := range ids {
		m.home_to[ids[i]] = struct{}{}
	}
}

// ClearHomeTo clears the "home_to" edge to the Person entity.
func (m *PlanetMutation) ClearHomeTo() {
	m.clearedhome_to = true
}

// HomeToCleared reports if the "home_to" edge to the Person entity was cleared.
func (m *PlanetMutation) HomeToCleared() bool {
	return m.clearedhome_to
}

// RemoveHomeToIDs removes the "home_to" edge to the Person entity by IDs.
func (m *PlanetMutation) RemoveHomeToIDs(ids ...int) {
	if m.removedhome_to == nil {
		m.removedhome_to = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.home_to, ids[i])
		m.removedhome_to[ids[i]] = struct{}{}
	}
}

// RemovedHomeTo returns the removed IDs of the "home_to" edge to the Person entity.
func (m *PlanetMutation) RemovedHomeToIDs() (ids []int) {
	for id := range m.removedhome_to {
		ids = append(ids, id)
	}
	return
}

// HomeToIDs returns the "home_to" edge IDs in the mutation.
func (m *PlanetMutation) HomeToIDs() (ids []int) {
	for id := range m.home_to {
		ids = append(ids, id)
	}
	return
}

// ResetHomeTo resets all changes to the "home_to" edge.
func (m *PlanetMutation) ResetHomeTo() {
	m.home_to = nil
	m.clearedhome_to = false
	m.removedhome_to = nil
}

// AddAppearedInIDs adds the "appeared_in" edge to the Film entity by ids.
func (m *PlanetMutation) AddAppearedInIDs(ids ...int) {
	if m.appeared_in == nil {
		m.appeared_in = make(map[int]struct{})
	}
	for i := range ids {
		m.appeared_in[ids[i]] = struct{}{}
	}
}

// ClearAppearedIn clears the "appeared_in" edge to the Film entity.
func (m *PlanetMutation) ClearAppearedIn() {
	m.clearedappeared_in = true
}

// AppearedInCleared reports if the "appeared_in" edge to the Film entity was cleared.
func (m *PlanetMutation) AppearedInCleared() bool {
	return m.clearedappeared_in
}

// RemoveAppearedInIDs removes the "appeared_in" edge to the Film entity by IDs.
func (m *PlanetMutation) RemoveAppearedInIDs(ids ...int) {
	if m.removedappeared_in == nil {
		m.removedappeared_in = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.appeared_in, ids[i])
		m.removedappeared_in[ids[i]] = struct{}{}
	}
}

// RemovedAppearedIn returns the removed IDs of the "appeared_in" edge to the Film entity.
func (m *PlanetMutation) RemovedAppearedInIDs() (ids []int) {
	for id := range m.removedappeared_in {
		ids = append(ids, id)
	}
	return
}

// AppearedInIDs returns the "appeared_in" edge IDs in the mutation.
func (m *PlanetMutation) AppearedInIDs() (ids []int) {
	for id := range m.appeared_in {
		ids = append(ids, id)
	}
	return
}

// ResetAppearedIn resets all changes to the "appeared_in" edge.
func (m *PlanetMutation) ResetAppearedIn() {
	m.appeared_in = nil
	m.clearedappeared_in = false
	m.removedappeared_in = nil
}

// AddOriginOfIDs adds the "origin_of" edge to the Species entity by ids.
func (m *PlanetMutation) AddOriginOfIDs(ids ...int) {
	if m.origin_of == nil {
		m.origin_of = make(map[int]struct{})
	}
	for i := range ids {
		m.origin_of[ids[i]] = struct{}{}
	}
}

// ClearOriginOf clears the "origin_of" edge to the Species entity.
func (m *PlanetMutation) ClearOriginOf() {
	m.clearedorigin_of = true
}

// OriginOfCleared reports if the "origin_of" edge to the Species entity was cleared.
func (m *PlanetMutation) OriginOfCleared() bool {
	return m.clearedorigin_of
}

// RemoveOriginOfIDs removes the "origin_of" edge to the Species entity by IDs.
func (m *PlanetMutation) RemoveOriginOfIDs(ids ...int) {
	if m.removedorigin_of == nil {
		m.removedorigin_of = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.origin_of, ids[i])
		m.removedorigin_of[ids[i]] = struct{}{}
	}
}

// RemovedOriginOf returns the removed IDs of the "origin_of" edge to the Species entity.
func (m *PlanetMutation) RemovedOriginOfIDs() (ids []int) {
	for id := range m.removedorigin_of {
		ids = append(ids, id)
	}
	return
}

// OriginOfIDs returns the "origin_of" edge IDs in the mutation.
func (m *PlanetMutation) OriginOfIDs() (ids []int) {
	for id := range m.origin_of {
		ids = append(ids, id)
	}
	return
}

// ResetOriginOf resets all changes to the "origin_of" edge.
func (m *PlanetMutation) ResetOriginOf() {
	m.origin_of = nil
	m.clearedorigin_of = false
	m.removedorigin_of = nil
}

// Where appends a list predicates to the PlanetMutation builder.
func (m *PlanetMutation) Where(ps ...predicate.Planet) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *PlanetMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Planet).
func (m *PlanetMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PlanetMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.climate != nil {
		fields = append(fields, planet.FieldClimate)
	}
	if m.diameter != nil {
		fields = append(fields, planet.FieldDiameter)
	}
	if m.gravity != nil {
		fields = append(fields, planet.FieldGravity)
	}
	if m.name != nil {
		fields = append(fields, planet.FieldName)
	}
	if m.orbital_period != nil {
		fields = append(fields, planet.FieldOrbitalPeriod)
	}
	if m.population != nil {
		fields = append(fields, planet.FieldPopulation)
	}
	if m.rotation_period != nil {
		fields = append(fields, planet.FieldRotationPeriod)
	}
	if m.surface_water != nil {
		fields = append(fields, planet.FieldSurfaceWater)
	}
	if m.terrain != nil {
		fields = append(fields, planet.FieldTerrain)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PlanetMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case planet.FieldClimate:
		return m.Climate()
	case planet.FieldDiameter:
		return m.Diameter()
	case planet.FieldGravity:
		return m.Gravity()
	case planet.FieldName:
		return m.Name()
	case planet.FieldOrbitalPeriod:
		return m.OrbitalPeriod()
	case planet.FieldPopulation:
		return m.Population()
	case planet.FieldRotationPeriod:
		return m.RotationPeriod()
	case planet.FieldSurfaceWater:
		return m.SurfaceWater()
	case planet.FieldTerrain:
		return m.Terrain()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PlanetMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case planet.FieldClimate:
		return m.OldClimate(ctx)
	case planet.FieldDiameter:
		return m.OldDiameter(ctx)
	case planet.FieldGravity:
		return m.OldGravity(ctx)
	case planet.FieldName:
		return m.OldName(ctx)
	case planet.FieldOrbitalPeriod:
		return m.OldOrbitalPeriod(ctx)
	case planet.FieldPopulation:
		return m.OldPopulation(ctx)
	case planet.FieldRotationPeriod:
		return m.OldRotationPeriod(ctx)
	case planet.FieldSurfaceWater:
		return m.OldSurfaceWater(ctx)
	case planet.FieldTerrain:
		return m.OldTerrain(ctx)
	}
	return nil, fmt.Errorf("unknown Planet field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlanetMutation) SetField(name string, value ent.Value) error {
	switch name {
	case planet.FieldClimate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClimate(v)
		return nil
	case planet.FieldDiameter:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiameter(v)
		return nil
	case planet.FieldGravity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGravity(v)
		return nil
	case planet.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case planet.FieldOrbitalPeriod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrbitalPeriod(v)
		return nil
	case planet.FieldPopulation:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPopulation(v)
		return nil
	case planet.FieldRotationPeriod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRotationPeriod(v)
		return nil
	case planet.FieldSurfaceWater:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSurfaceWater(v)
		return nil
	case planet.FieldTerrain:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTerrain(v)
		return nil
	}
	return fmt.Errorf("unknown Planet field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PlanetMutation) AddedFields() []string {
	var fields []string
	if m.adddiameter != nil {
		fields = append(fields, planet.FieldDiameter)
	}
	if m.addpopulation != nil {
		fields = append(fields, planet.FieldPopulation)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PlanetMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case planet.FieldDiameter:
		return m.AddedDiameter()
	case planet.FieldPopulation:
		return m.AddedPopulation()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlanetMutation) AddField(name string, value ent.Value) error {
	switch name {
	case planet.FieldDiameter:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDiameter(v)
		return nil
	case planet.FieldPopulation:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPopulation(v)
		return nil
	}
	return fmt.Errorf("unknown Planet numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PlanetMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(planet.FieldDiameter) {
		fields = append(fields, planet.FieldDiameter)
	}
	if m.FieldCleared(planet.FieldPopulation) {
		fields = append(fields, planet.FieldPopulation)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PlanetMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PlanetMutation) ClearField(name string) error {
	switch name {
	case planet.FieldDiameter:
		m.ClearDiameter()
		return nil
	case planet.FieldPopulation:
		m.ClearPopulation()
		return nil
	}
	return fmt.Errorf("unknown Planet nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PlanetMutation) ResetField(name string) error {
	switch name {
	case planet.FieldClimate:
		m.ResetClimate()
		return nil
	case planet.FieldDiameter:
		m.ResetDiameter()
		return nil
	case planet.FieldGravity:
		m.ResetGravity()
		return nil
	case planet.FieldName:
		m.ResetName()
		return nil
	case planet.FieldOrbitalPeriod:
		m.ResetOrbitalPeriod()
		return nil
	case planet.FieldPopulation:
		m.ResetPopulation()
		return nil
	case planet.FieldRotationPeriod:
		m.ResetRotationPeriod()
		return nil
	case planet.FieldSurfaceWater:
		m.ResetSurfaceWater()
		return nil
	case planet.FieldTerrain:
		m.ResetTerrain()
		return nil
	}
	return fmt.Errorf("unknown Planet field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PlanetMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.home_to != nil {
		edges = append(edges, planet.EdgeHomeTo)
	}
	if m.appeared_in != nil {
		edges = append(edges, planet.EdgeAppearedIn)
	}
	if m.origin_of != nil {
		edges = append(edges, planet.EdgeOriginOf)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PlanetMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case planet.EdgeHomeTo:
		ids := make([]ent.Value, 0, len(m.home_to))
		for id := range m.home_to {
			ids = append(ids, id)
		}
		return ids
	case planet.EdgeAppearedIn:
		ids := make([]ent.Value, 0, len(m.appeared_in))
		for id := range m.appeared_in {
			ids = append(ids, id)
		}
		return ids
	case planet.EdgeOriginOf:
		ids := make([]ent.Value, 0, len(m.origin_of))
		for id := range m.origin_of {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PlanetMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedhome_to != nil {
		edges = append(edges, planet.EdgeHomeTo)
	}
	if m.removedappeared_in != nil {
		edges = append(edges, planet.EdgeAppearedIn)
	}
	if m.removedorigin_of != nil {
		edges = append(edges, planet.EdgeOriginOf)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PlanetMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case planet.EdgeHomeTo:
		ids := make([]ent.Value, 0, len(m.removedhome_to))
		for id := range m.removedhome_to {
			ids = append(ids, id)
		}
		return ids
	case planet.EdgeAppearedIn:
		ids := make([]ent.Value, 0, len(m.removedappeared_in))
		for id := range m.removedappeared_in {
			ids = append(ids, id)
		}
		return ids
	case planet.EdgeOriginOf:
		ids := make([]ent.Value, 0, len(m.removedorigin_of))
		for id := range m.removedorigin_of {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PlanetMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedhome_to {
		edges = append(edges, planet.EdgeHomeTo)
	}
	if m.clearedappeared_in {
		edges = append(edges, planet.EdgeAppearedIn)
	}
	if m.clearedorigin_of {
		edges = append(edges, planet.EdgeOriginOf)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PlanetMutation) EdgeCleared(name string) bool {
	switch name {
	case planet.EdgeHomeTo:
		return m.clearedhome_to
	case planet.EdgeAppearedIn:
		return m.clearedappeared_in
	case planet.EdgeOriginOf:
		return m.clearedorigin_of
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PlanetMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Planet unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PlanetMutation) ResetEdge(name string) error {
	switch name {
	case planet.EdgeHomeTo:
		m.ResetHomeTo()
		return nil
	case planet.EdgeAppearedIn:
		m.ResetAppearedIn()
		return nil
	case planet.EdgeOriginOf:
		m.ResetOriginOf()
		return nil
	}
	return fmt.Errorf("unknown Planet edge %s", name)
}

// SpeciesMutation represents an operation that mutates the Species nodes in the graph.
type SpeciesMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	average_height         *int
	addaverage_height      *int
	average_lifespan       *string
	classification         *string
	designation            *string
	name                   *string
	skin_color             *string
	eye_color              *string
	hair_color             *string
	language               *string
	clearedFields          map[string]struct{}
	originates_from        map[int]struct{}
	removedoriginates_from map[int]struct{}
	clearedoriginates_from bool
	appeared_in            map[int]struct{}
	removedappeared_in     map[int]struct{}
	clearedappeared_in     bool
	includes_person        map[int]struct{}
	removedincludes_person map[int]struct{}
	clearedincludes_person bool
	done                   bool
	oldValue               func(context.Context) (*Species, error)
	predicates             []predicate.Species
}

var _ ent.Mutation = (*SpeciesMutation)(nil)

// speciesOption allows management of the mutation configuration using functional options.
type speciesOption func(*SpeciesMutation)

// newSpeciesMutation creates new mutation for the Species entity.
func newSpeciesMutation(c config, op Op, opts ...speciesOption) *SpeciesMutation {
	m := &SpeciesMutation{
		config:        c,
		op:            op,
		typ:           TypeSpecies,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSpeciesID sets the ID field of the mutation.
func withSpeciesID(id int) speciesOption {
	return func(m *SpeciesMutation) {
		var (
			err   error
			once  sync.Once
			value *Species
		)
		m.oldValue = func(ctx context.Context) (*Species, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Species.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSpecies sets the old Species of the mutation.
func withSpecies(node *Species) speciesOption {
	return func(m *SpeciesMutation) {
		m.oldValue = func(context.Context) (*Species, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SpeciesMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SpeciesMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SpeciesMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SpeciesMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Species.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAverageHeight sets the "average_height" field.
func (m *SpeciesMutation) SetAverageHeight(i int) {
	m.average_height = &i
	m.addaverage_height = nil
}

// AverageHeight returns the value of the "average_height" field in the mutation.
func (m *SpeciesMutation) AverageHeight() (r int, exists bool) {
	v := m.average_height
	if v == nil {
		return
	}
	return *v, true
}

// OldAverageHeight returns the old "average_height" field's value of the Species entity.
// If the Species object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpeciesMutation) OldAverageHeight(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAverageHeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAverageHeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAverageHeight: %w", err)
	}
	return oldValue.AverageHeight, nil
}

// AddAverageHeight adds i to the "average_height" field.
func (m *SpeciesMutation) AddAverageHeight(i int) {
	if m.addaverage_height != nil {
		*m.addaverage_height += i
	} else {
		m.addaverage_height = &i
	}
}

// AddedAverageHeight returns the value that was added to the "average_height" field in this mutation.
func (m *SpeciesMutation) AddedAverageHeight() (r int, exists bool) {
	v := m.addaverage_height
	if v == nil {
		return
	}
	return *v, true
}

// ResetAverageHeight resets all changes to the "average_height" field.
func (m *SpeciesMutation) ResetAverageHeight() {
	m.average_height = nil
	m.addaverage_height = nil
}

// SetAverageLifespan sets the "average_lifespan" field.
func (m *SpeciesMutation) SetAverageLifespan(s string) {
	m.average_lifespan = &s
}

// AverageLifespan returns the value of the "average_lifespan" field in the mutation.
func (m *SpeciesMutation) AverageLifespan() (r string, exists bool) {
	v := m.average_lifespan
	if v == nil {
		return
	}
	return *v, true
}

// OldAverageLifespan returns the old "average_lifespan" field's value of the Species entity.
// If the Species object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpeciesMutation) OldAverageLifespan(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAverageLifespan is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAverageLifespan requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAverageLifespan: %w", err)
	}
	return oldValue.AverageLifespan, nil
}

// ResetAverageLifespan resets all changes to the "average_lifespan" field.
func (m *SpeciesMutation) ResetAverageLifespan() {
	m.average_lifespan = nil
}

// SetClassification sets the "classification" field.
func (m *SpeciesMutation) SetClassification(s string) {
	m.classification = &s
}

// Classification returns the value of the "classification" field in the mutation.
func (m *SpeciesMutation) Classification() (r string, exists bool) {
	v := m.classification
	if v == nil {
		return
	}
	return *v, true
}

// OldClassification returns the old "classification" field's value of the Species entity.
// If the Species object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpeciesMutation) OldClassification(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClassification is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClassification requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClassification: %w", err)
	}
	return oldValue.Classification, nil
}

// ResetClassification resets all changes to the "classification" field.
func (m *SpeciesMutation) ResetClassification() {
	m.classification = nil
}

// SetDesignation sets the "designation" field.
func (m *SpeciesMutation) SetDesignation(s string) {
	m.designation = &s
}

// Designation returns the value of the "designation" field in the mutation.
func (m *SpeciesMutation) Designation() (r string, exists bool) {
	v := m.designation
	if v == nil {
		return
	}
	return *v, true
}

// OldDesignation returns the old "designation" field's value of the Species entity.
// If the Species object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpeciesMutation) OldDesignation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDesignation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDesignation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDesignation: %w", err)
	}
	return oldValue.Designation, nil
}

// ResetDesignation resets all changes to the "designation" field.
func (m *SpeciesMutation) ResetDesignation() {
	m.designation = nil
}

// SetName sets the "name" field.
func (m *SpeciesMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SpeciesMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Species entity.
// If the Species object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpeciesMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SpeciesMutation) ResetName() {
	m.name = nil
}

// SetSkinColor sets the "skin_color" field.
func (m *SpeciesMutation) SetSkinColor(s string) {
	m.skin_color = &s
}

// SkinColor returns the value of the "skin_color" field in the mutation.
func (m *SpeciesMutation) SkinColor() (r string, exists bool) {
	v := m.skin_color
	if v == nil {
		return
	}
	return *v, true
}

// OldSkinColor returns the old "skin_color" field's value of the Species entity.
// If the Species object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpeciesMutation) OldSkinColor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSkinColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSkinColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSkinColor: %w", err)
	}
	return oldValue.SkinColor, nil
}

// ResetSkinColor resets all changes to the "skin_color" field.
func (m *SpeciesMutation) ResetSkinColor() {
	m.skin_color = nil
}

// SetEyeColor sets the "eye_color" field.
func (m *SpeciesMutation) SetEyeColor(s string) {
	m.eye_color = &s
}

// EyeColor returns the value of the "eye_color" field in the mutation.
func (m *SpeciesMutation) EyeColor() (r string, exists bool) {
	v := m.eye_color
	if v == nil {
		return
	}
	return *v, true
}

// OldEyeColor returns the old "eye_color" field's value of the Species entity.
// If the Species object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpeciesMutation) OldEyeColor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEyeColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEyeColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEyeColor: %w", err)
	}
	return oldValue.EyeColor, nil
}

// ResetEyeColor resets all changes to the "eye_color" field.
func (m *SpeciesMutation) ResetEyeColor() {
	m.eye_color = nil
}

// SetHairColor sets the "hair_color" field.
func (m *SpeciesMutation) SetHairColor(s string) {
	m.hair_color = &s
}

// HairColor returns the value of the "hair_color" field in the mutation.
func (m *SpeciesMutation) HairColor() (r string, exists bool) {
	v := m.hair_color
	if v == nil {
		return
	}
	return *v, true
}

// OldHairColor returns the old "hair_color" field's value of the Species entity.
// If the Species object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpeciesMutation) OldHairColor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHairColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHairColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHairColor: %w", err)
	}
	return oldValue.HairColor, nil
}

// ResetHairColor resets all changes to the "hair_color" field.
func (m *SpeciesMutation) ResetHairColor() {
	m.hair_color = nil
}

// SetLanguage sets the "language" field.
func (m *SpeciesMutation) SetLanguage(s string) {
	m.language = &s
}

// Language returns the value of the "language" field in the mutation.
func (m *SpeciesMutation) Language() (r string, exists bool) {
	v := m.language
	if v == nil {
		return
	}
	return *v, true
}

// OldLanguage returns the old "language" field's value of the Species entity.
// If the Species object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpeciesMutation) OldLanguage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLanguage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLanguage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLanguage: %w", err)
	}
	return oldValue.Language, nil
}

// ResetLanguage resets all changes to the "language" field.
func (m *SpeciesMutation) ResetLanguage() {
	m.language = nil
}

// AddOriginatesFromIDs adds the "originates_from" edge to the Planet entity by ids.
func (m *SpeciesMutation) AddOriginatesFromIDs(ids ...int) {
	if m.originates_from == nil {
		m.originates_from = make(map[int]struct{})
	}
	for i := range ids {
		m.originates_from[ids[i]] = struct{}{}
	}
}

// ClearOriginatesFrom clears the "originates_from" edge to the Planet entity.
func (m *SpeciesMutation) ClearOriginatesFrom() {
	m.clearedoriginates_from = true
}

// OriginatesFromCleared reports if the "originates_from" edge to the Planet entity was cleared.
func (m *SpeciesMutation) OriginatesFromCleared() bool {
	return m.clearedoriginates_from
}

// RemoveOriginatesFromIDs removes the "originates_from" edge to the Planet entity by IDs.
func (m *SpeciesMutation) RemoveOriginatesFromIDs(ids ...int) {
	if m.removedoriginates_from == nil {
		m.removedoriginates_from = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.originates_from, ids[i])
		m.removedoriginates_from[ids[i]] = struct{}{}
	}
}

// RemovedOriginatesFrom returns the removed IDs of the "originates_from" edge to the Planet entity.
func (m *SpeciesMutation) RemovedOriginatesFromIDs() (ids []int) {
	for id := range m.removedoriginates_from {
		ids = append(ids, id)
	}
	return
}

// OriginatesFromIDs returns the "originates_from" edge IDs in the mutation.
func (m *SpeciesMutation) OriginatesFromIDs() (ids []int) {
	for id := range m.originates_from {
		ids = append(ids, id)
	}
	return
}

// ResetOriginatesFrom resets all changes to the "originates_from" edge.
func (m *SpeciesMutation) ResetOriginatesFrom() {
	m.originates_from = nil
	m.clearedoriginates_from = false
	m.removedoriginates_from = nil
}

// AddAppearedInIDs adds the "appeared_in" edge to the Film entity by ids.
func (m *SpeciesMutation) AddAppearedInIDs(ids ...int) {
	if m.appeared_in == nil {
		m.appeared_in = make(map[int]struct{})
	}
	for i := range ids {
		m.appeared_in[ids[i]] = struct{}{}
	}
}

// ClearAppearedIn clears the "appeared_in" edge to the Film entity.
func (m *SpeciesMutation) ClearAppearedIn() {
	m.clearedappeared_in = true
}

// AppearedInCleared reports if the "appeared_in" edge to the Film entity was cleared.
func (m *SpeciesMutation) AppearedInCleared() bool {
	return m.clearedappeared_in
}

// RemoveAppearedInIDs removes the "appeared_in" edge to the Film entity by IDs.
func (m *SpeciesMutation) RemoveAppearedInIDs(ids ...int) {
	if m.removedappeared_in == nil {
		m.removedappeared_in = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.appeared_in, ids[i])
		m.removedappeared_in[ids[i]] = struct{}{}
	}
}

// RemovedAppearedIn returns the removed IDs of the "appeared_in" edge to the Film entity.
func (m *SpeciesMutation) RemovedAppearedInIDs() (ids []int) {
	for id := range m.removedappeared_in {
		ids = append(ids, id)
	}
	return
}

// AppearedInIDs returns the "appeared_in" edge IDs in the mutation.
func (m *SpeciesMutation) AppearedInIDs() (ids []int) {
	for id := range m.appeared_in {
		ids = append(ids, id)
	}
	return
}

// ResetAppearedIn resets all changes to the "appeared_in" edge.
func (m *SpeciesMutation) ResetAppearedIn() {
	m.appeared_in = nil
	m.clearedappeared_in = false
	m.removedappeared_in = nil
}

// AddIncludesPersonIDs adds the "includes_person" edge to the Person entity by ids.
func (m *SpeciesMutation) AddIncludesPersonIDs(ids ...int) {
	if m.includes_person == nil {
		m.includes_person = make(map[int]struct{})
	}
	for i := range ids {
		m.includes_person[ids[i]] = struct{}{}
	}
}

// ClearIncludesPerson clears the "includes_person" edge to the Person entity.
func (m *SpeciesMutation) ClearIncludesPerson() {
	m.clearedincludes_person = true
}

// IncludesPersonCleared reports if the "includes_person" edge to the Person entity was cleared.
func (m *SpeciesMutation) IncludesPersonCleared() bool {
	return m.clearedincludes_person
}

// RemoveIncludesPersonIDs removes the "includes_person" edge to the Person entity by IDs.
func (m *SpeciesMutation) RemoveIncludesPersonIDs(ids ...int) {
	if m.removedincludes_person == nil {
		m.removedincludes_person = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.includes_person, ids[i])
		m.removedincludes_person[ids[i]] = struct{}{}
	}
}

// RemovedIncludesPerson returns the removed IDs of the "includes_person" edge to the Person entity.
func (m *SpeciesMutation) RemovedIncludesPersonIDs() (ids []int) {
	for id := range m.removedincludes_person {
		ids = append(ids, id)
	}
	return
}

// IncludesPersonIDs returns the "includes_person" edge IDs in the mutation.
func (m *SpeciesMutation) IncludesPersonIDs() (ids []int) {
	for id := range m.includes_person {
		ids = append(ids, id)
	}
	return
}

// ResetIncludesPerson resets all changes to the "includes_person" edge.
func (m *SpeciesMutation) ResetIncludesPerson() {
	m.includes_person = nil
	m.clearedincludes_person = false
	m.removedincludes_person = nil
}

// Where appends a list predicates to the SpeciesMutation builder.
func (m *SpeciesMutation) Where(ps ...predicate.Species) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *SpeciesMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Species).
func (m *SpeciesMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SpeciesMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.average_height != nil {
		fields = append(fields, species.FieldAverageHeight)
	}
	if m.average_lifespan != nil {
		fields = append(fields, species.FieldAverageLifespan)
	}
	if m.classification != nil {
		fields = append(fields, species.FieldClassification)
	}
	if m.designation != nil {
		fields = append(fields, species.FieldDesignation)
	}
	if m.name != nil {
		fields = append(fields, species.FieldName)
	}
	if m.skin_color != nil {
		fields = append(fields, species.FieldSkinColor)
	}
	if m.eye_color != nil {
		fields = append(fields, species.FieldEyeColor)
	}
	if m.hair_color != nil {
		fields = append(fields, species.FieldHairColor)
	}
	if m.language != nil {
		fields = append(fields, species.FieldLanguage)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SpeciesMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case species.FieldAverageHeight:
		return m.AverageHeight()
	case species.FieldAverageLifespan:
		return m.AverageLifespan()
	case species.FieldClassification:
		return m.Classification()
	case species.FieldDesignation:
		return m.Designation()
	case species.FieldName:
		return m.Name()
	case species.FieldSkinColor:
		return m.SkinColor()
	case species.FieldEyeColor:
		return m.EyeColor()
	case species.FieldHairColor:
		return m.HairColor()
	case species.FieldLanguage:
		return m.Language()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SpeciesMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case species.FieldAverageHeight:
		return m.OldAverageHeight(ctx)
	case species.FieldAverageLifespan:
		return m.OldAverageLifespan(ctx)
	case species.FieldClassification:
		return m.OldClassification(ctx)
	case species.FieldDesignation:
		return m.OldDesignation(ctx)
	case species.FieldName:
		return m.OldName(ctx)
	case species.FieldSkinColor:
		return m.OldSkinColor(ctx)
	case species.FieldEyeColor:
		return m.OldEyeColor(ctx)
	case species.FieldHairColor:
		return m.OldHairColor(ctx)
	case species.FieldLanguage:
		return m.OldLanguage(ctx)
	}
	return nil, fmt.Errorf("unknown Species field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SpeciesMutation) SetField(name string, value ent.Value) error {
	switch name {
	case species.FieldAverageHeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAverageHeight(v)
		return nil
	case species.FieldAverageLifespan:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAverageLifespan(v)
		return nil
	case species.FieldClassification:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClassification(v)
		return nil
	case species.FieldDesignation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDesignation(v)
		return nil
	case species.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case species.FieldSkinColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSkinColor(v)
		return nil
	case species.FieldEyeColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEyeColor(v)
		return nil
	case species.FieldHairColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHairColor(v)
		return nil
	case species.FieldLanguage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLanguage(v)
		return nil
	}
	return fmt.Errorf("unknown Species field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SpeciesMutation) AddedFields() []string {
	var fields []string
	if m.addaverage_height != nil {
		fields = append(fields, species.FieldAverageHeight)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SpeciesMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case species.FieldAverageHeight:
		return m.AddedAverageHeight()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SpeciesMutation) AddField(name string, value ent.Value) error {
	switch name {
	case species.FieldAverageHeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAverageHeight(v)
		return nil
	}
	return fmt.Errorf("unknown Species numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SpeciesMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SpeciesMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SpeciesMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Species nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SpeciesMutation) ResetField(name string) error {
	switch name {
	case species.FieldAverageHeight:
		m.ResetAverageHeight()
		return nil
	case species.FieldAverageLifespan:
		m.ResetAverageLifespan()
		return nil
	case species.FieldClassification:
		m.ResetClassification()
		return nil
	case species.FieldDesignation:
		m.ResetDesignation()
		return nil
	case species.FieldName:
		m.ResetName()
		return nil
	case species.FieldSkinColor:
		m.ResetSkinColor()
		return nil
	case species.FieldEyeColor:
		m.ResetEyeColor()
		return nil
	case species.FieldHairColor:
		m.ResetHairColor()
		return nil
	case species.FieldLanguage:
		m.ResetLanguage()
		return nil
	}
	return fmt.Errorf("unknown Species field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SpeciesMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.originates_from != nil {
		edges = append(edges, species.EdgeOriginatesFrom)
	}
	if m.appeared_in != nil {
		edges = append(edges, species.EdgeAppearedIn)
	}
	if m.includes_person != nil {
		edges = append(edges, species.EdgeIncludesPerson)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SpeciesMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case species.EdgeOriginatesFrom:
		ids := make([]ent.Value, 0, len(m.originates_from))
		for id := range m.originates_from {
			ids = append(ids, id)
		}
		return ids
	case species.EdgeAppearedIn:
		ids := make([]ent.Value, 0, len(m.appeared_in))
		for id := range m.appeared_in {
			ids = append(ids, id)
		}
		return ids
	case species.EdgeIncludesPerson:
		ids := make([]ent.Value, 0, len(m.includes_person))
		for id := range m.includes_person {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SpeciesMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedoriginates_from != nil {
		edges = append(edges, species.EdgeOriginatesFrom)
	}
	if m.removedappeared_in != nil {
		edges = append(edges, species.EdgeAppearedIn)
	}
	if m.removedincludes_person != nil {
		edges = append(edges, species.EdgeIncludesPerson)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SpeciesMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case species.EdgeOriginatesFrom:
		ids := make([]ent.Value, 0, len(m.removedoriginates_from))
		for id := range m.removedoriginates_from {
			ids = append(ids, id)
		}
		return ids
	case species.EdgeAppearedIn:
		ids := make([]ent.Value, 0, len(m.removedappeared_in))
		for id := range m.removedappeared_in {
			ids = append(ids, id)
		}
		return ids
	case species.EdgeIncludesPerson:
		ids := make([]ent.Value, 0, len(m.removedincludes_person))
		for id := range m.removedincludes_person {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SpeciesMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedoriginates_from {
		edges = append(edges, species.EdgeOriginatesFrom)
	}
	if m.clearedappeared_in {
		edges = append(edges, species.EdgeAppearedIn)
	}
	if m.clearedincludes_person {
		edges = append(edges, species.EdgeIncludesPerson)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SpeciesMutation) EdgeCleared(name string) bool {
	switch name {
	case species.EdgeOriginatesFrom:
		return m.clearedoriginates_from
	case species.EdgeAppearedIn:
		return m.clearedappeared_in
	case species.EdgeIncludesPerson:
		return m.clearedincludes_person
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SpeciesMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Species unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SpeciesMutation) ResetEdge(name string) error {
	switch name {
	case species.EdgeOriginatesFrom:
		m.ResetOriginatesFrom()
		return nil
	case species.EdgeAppearedIn:
		m.ResetAppearedIn()
		return nil
	case species.EdgeIncludesPerson:
		m.ResetIncludesPerson()
		return nil
	}
	return fmt.Errorf("unknown Species edge %s", name)
}

// StarshipMutation represents an operation that mutates the Starship nodes in the graph.
type StarshipMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	cargo_capacity         *int
	addcargo_capacity      *int
	class                  *string
	consumables            *string
	cost_in_credits        *int
	addcost_in_credits     *int
	crew                   *string
	hyperdrive_rating      *string
	length                 *float64
	addlength              *float64
	manufacturer           *string
	max_atmosphering_speed *string
	maximum_megalights     *string
	model                  *string
	name                   *string
	passenger_capacity     *int
	addpassenger_capacity  *int
	clearedFields          map[string]struct{}
	appeared_in            map[int]struct{}
	removedappeared_in     map[int]struct{}
	clearedappeared_in     bool
	piloted_by             map[int]struct{}
	removedpiloted_by      map[int]struct{}
	clearedpiloted_by      bool
	done                   bool
	oldValue               func(context.Context) (*Starship, error)
	predicates             []predicate.Starship
}

var _ ent.Mutation = (*StarshipMutation)(nil)

// starshipOption allows management of the mutation configuration using functional options.
type starshipOption func(*StarshipMutation)

// newStarshipMutation creates new mutation for the Starship entity.
func newStarshipMutation(c config, op Op, opts ...starshipOption) *StarshipMutation {
	m := &StarshipMutation{
		config:        c,
		op:            op,
		typ:           TypeStarship,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStarshipID sets the ID field of the mutation.
func withStarshipID(id int) starshipOption {
	return func(m *StarshipMutation) {
		var (
			err   error
			once  sync.Once
			value *Starship
		)
		m.oldValue = func(ctx context.Context) (*Starship, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Starship.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStarship sets the old Starship of the mutation.
func withStarship(node *Starship) starshipOption {
	return func(m *StarshipMutation) {
		m.oldValue = func(context.Context) (*Starship, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StarshipMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StarshipMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StarshipMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StarshipMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Starship.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCargoCapacity sets the "cargo_capacity" field.
func (m *StarshipMutation) SetCargoCapacity(i int) {
	m.cargo_capacity = &i
	m.addcargo_capacity = nil
}

// CargoCapacity returns the value of the "cargo_capacity" field in the mutation.
func (m *StarshipMutation) CargoCapacity() (r int, exists bool) {
	v := m.cargo_capacity
	if v == nil {
		return
	}
	return *v, true
}

// OldCargoCapacity returns the old "cargo_capacity" field's value of the Starship entity.
// If the Starship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StarshipMutation) OldCargoCapacity(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCargoCapacity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCargoCapacity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCargoCapacity: %w", err)
	}
	return oldValue.CargoCapacity, nil
}

// AddCargoCapacity adds i to the "cargo_capacity" field.
func (m *StarshipMutation) AddCargoCapacity(i int) {
	if m.addcargo_capacity != nil {
		*m.addcargo_capacity += i
	} else {
		m.addcargo_capacity = &i
	}
}

// AddedCargoCapacity returns the value that was added to the "cargo_capacity" field in this mutation.
func (m *StarshipMutation) AddedCargoCapacity() (r int, exists bool) {
	v := m.addcargo_capacity
	if v == nil {
		return
	}
	return *v, true
}

// ClearCargoCapacity clears the value of the "cargo_capacity" field.
func (m *StarshipMutation) ClearCargoCapacity() {
	m.cargo_capacity = nil
	m.addcargo_capacity = nil
	m.clearedFields[starship.FieldCargoCapacity] = struct{}{}
}

// CargoCapacityCleared returns if the "cargo_capacity" field was cleared in this mutation.
func (m *StarshipMutation) CargoCapacityCleared() bool {
	_, ok := m.clearedFields[starship.FieldCargoCapacity]
	return ok
}

// ResetCargoCapacity resets all changes to the "cargo_capacity" field.
func (m *StarshipMutation) ResetCargoCapacity() {
	m.cargo_capacity = nil
	m.addcargo_capacity = nil
	delete(m.clearedFields, starship.FieldCargoCapacity)
}

// SetClass sets the "class" field.
func (m *StarshipMutation) SetClass(s string) {
	m.class = &s
}

// Class returns the value of the "class" field in the mutation.
func (m *StarshipMutation) Class() (r string, exists bool) {
	v := m.class
	if v == nil {
		return
	}
	return *v, true
}

// OldClass returns the old "class" field's value of the Starship entity.
// If the Starship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StarshipMutation) OldClass(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClass is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClass requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClass: %w", err)
	}
	return oldValue.Class, nil
}

// ResetClass resets all changes to the "class" field.
func (m *StarshipMutation) ResetClass() {
	m.class = nil
}

// SetConsumables sets the "consumables" field.
func (m *StarshipMutation) SetConsumables(s string) {
	m.consumables = &s
}

// Consumables returns the value of the "consumables" field in the mutation.
func (m *StarshipMutation) Consumables() (r string, exists bool) {
	v := m.consumables
	if v == nil {
		return
	}
	return *v, true
}

// OldConsumables returns the old "consumables" field's value of the Starship entity.
// If the Starship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StarshipMutation) OldConsumables(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConsumables is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConsumables requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConsumables: %w", err)
	}
	return oldValue.Consumables, nil
}

// ResetConsumables resets all changes to the "consumables" field.
func (m *StarshipMutation) ResetConsumables() {
	m.consumables = nil
}

// SetCostInCredits sets the "cost_in_credits" field.
func (m *StarshipMutation) SetCostInCredits(i int) {
	m.cost_in_credits = &i
	m.addcost_in_credits = nil
}

// CostInCredits returns the value of the "cost_in_credits" field in the mutation.
func (m *StarshipMutation) CostInCredits() (r int, exists bool) {
	v := m.cost_in_credits
	if v == nil {
		return
	}
	return *v, true
}

// OldCostInCredits returns the old "cost_in_credits" field's value of the Starship entity.
// If the Starship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StarshipMutation) OldCostInCredits(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCostInCredits is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCostInCredits requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCostInCredits: %w", err)
	}
	return oldValue.CostInCredits, nil
}

// AddCostInCredits adds i to the "cost_in_credits" field.
func (m *StarshipMutation) AddCostInCredits(i int) {
	if m.addcost_in_credits != nil {
		*m.addcost_in_credits += i
	} else {
		m.addcost_in_credits = &i
	}
}

// AddedCostInCredits returns the value that was added to the "cost_in_credits" field in this mutation.
func (m *StarshipMutation) AddedCostInCredits() (r int, exists bool) {
	v := m.addcost_in_credits
	if v == nil {
		return
	}
	return *v, true
}

// ResetCostInCredits resets all changes to the "cost_in_credits" field.
func (m *StarshipMutation) ResetCostInCredits() {
	m.cost_in_credits = nil
	m.addcost_in_credits = nil
}

// SetCrew sets the "crew" field.
func (m *StarshipMutation) SetCrew(s string) {
	m.crew = &s
}

// Crew returns the value of the "crew" field in the mutation.
func (m *StarshipMutation) Crew() (r string, exists bool) {
	v := m.crew
	if v == nil {
		return
	}
	return *v, true
}

// OldCrew returns the old "crew" field's value of the Starship entity.
// If the Starship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StarshipMutation) OldCrew(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCrew is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCrew requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCrew: %w", err)
	}
	return oldValue.Crew, nil
}

// ResetCrew resets all changes to the "crew" field.
func (m *StarshipMutation) ResetCrew() {
	m.crew = nil
}

// SetHyperdriveRating sets the "hyperdrive_rating" field.
func (m *StarshipMutation) SetHyperdriveRating(s string) {
	m.hyperdrive_rating = &s
}

// HyperdriveRating returns the value of the "hyperdrive_rating" field in the mutation.
func (m *StarshipMutation) HyperdriveRating() (r string, exists bool) {
	v := m.hyperdrive_rating
	if v == nil {
		return
	}
	return *v, true
}

// OldHyperdriveRating returns the old "hyperdrive_rating" field's value of the Starship entity.
// If the Starship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StarshipMutation) OldHyperdriveRating(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHyperdriveRating is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHyperdriveRating requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHyperdriveRating: %w", err)
	}
	return oldValue.HyperdriveRating, nil
}

// ResetHyperdriveRating resets all changes to the "hyperdrive_rating" field.
func (m *StarshipMutation) ResetHyperdriveRating() {
	m.hyperdrive_rating = nil
}

// SetLength sets the "length" field.
func (m *StarshipMutation) SetLength(f float64) {
	m.length = &f
	m.addlength = nil
}

// Length returns the value of the "length" field in the mutation.
func (m *StarshipMutation) Length() (r float64, exists bool) {
	v := m.length
	if v == nil {
		return
	}
	return *v, true
}

// OldLength returns the old "length" field's value of the Starship entity.
// If the Starship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StarshipMutation) OldLength(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLength is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLength requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLength: %w", err)
	}
	return oldValue.Length, nil
}

// AddLength adds f to the "length" field.
func (m *StarshipMutation) AddLength(f float64) {
	if m.addlength != nil {
		*m.addlength += f
	} else {
		m.addlength = &f
	}
}

// AddedLength returns the value that was added to the "length" field in this mutation.
func (m *StarshipMutation) AddedLength() (r float64, exists bool) {
	v := m.addlength
	if v == nil {
		return
	}
	return *v, true
}

// ResetLength resets all changes to the "length" field.
func (m *StarshipMutation) ResetLength() {
	m.length = nil
	m.addlength = nil
}

// SetManufacturer sets the "manufacturer" field.
func (m *StarshipMutation) SetManufacturer(s string) {
	m.manufacturer = &s
}

// Manufacturer returns the value of the "manufacturer" field in the mutation.
func (m *StarshipMutation) Manufacturer() (r string, exists bool) {
	v := m.manufacturer
	if v == nil {
		return
	}
	return *v, true
}

// OldManufacturer returns the old "manufacturer" field's value of the Starship entity.
// If the Starship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StarshipMutation) OldManufacturer(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldManufacturer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldManufacturer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldManufacturer: %w", err)
	}
	return oldValue.Manufacturer, nil
}

// ResetManufacturer resets all changes to the "manufacturer" field.
func (m *StarshipMutation) ResetManufacturer() {
	m.manufacturer = nil
}

// SetMaxAtmospheringSpeed sets the "max_atmosphering_speed" field.
func (m *StarshipMutation) SetMaxAtmospheringSpeed(s string) {
	m.max_atmosphering_speed = &s
}

// MaxAtmospheringSpeed returns the value of the "max_atmosphering_speed" field in the mutation.
func (m *StarshipMutation) MaxAtmospheringSpeed() (r string, exists bool) {
	v := m.max_atmosphering_speed
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxAtmospheringSpeed returns the old "max_atmosphering_speed" field's value of the Starship entity.
// If the Starship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StarshipMutation) OldMaxAtmospheringSpeed(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxAtmospheringSpeed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxAtmospheringSpeed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxAtmospheringSpeed: %w", err)
	}
	return oldValue.MaxAtmospheringSpeed, nil
}

// ResetMaxAtmospheringSpeed resets all changes to the "max_atmosphering_speed" field.
func (m *StarshipMutation) ResetMaxAtmospheringSpeed() {
	m.max_atmosphering_speed = nil
}

// SetMaximumMegalights sets the "maximum_megalights" field.
func (m *StarshipMutation) SetMaximumMegalights(s string) {
	m.maximum_megalights = &s
}

// MaximumMegalights returns the value of the "maximum_megalights" field in the mutation.
func (m *StarshipMutation) MaximumMegalights() (r string, exists bool) {
	v := m.maximum_megalights
	if v == nil {
		return
	}
	return *v, true
}

// OldMaximumMegalights returns the old "maximum_megalights" field's value of the Starship entity.
// If the Starship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StarshipMutation) OldMaximumMegalights(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaximumMegalights is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaximumMegalights requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaximumMegalights: %w", err)
	}
	return oldValue.MaximumMegalights, nil
}

// ClearMaximumMegalights clears the value of the "maximum_megalights" field.
func (m *StarshipMutation) ClearMaximumMegalights() {
	m.maximum_megalights = nil
	m.clearedFields[starship.FieldMaximumMegalights] = struct{}{}
}

// MaximumMegalightsCleared returns if the "maximum_megalights" field was cleared in this mutation.
func (m *StarshipMutation) MaximumMegalightsCleared() bool {
	_, ok := m.clearedFields[starship.FieldMaximumMegalights]
	return ok
}

// ResetMaximumMegalights resets all changes to the "maximum_megalights" field.
func (m *StarshipMutation) ResetMaximumMegalights() {
	m.maximum_megalights = nil
	delete(m.clearedFields, starship.FieldMaximumMegalights)
}

// SetModel sets the "model" field.
func (m *StarshipMutation) SetModel(s string) {
	m.model = &s
}

// Model returns the value of the "model" field in the mutation.
func (m *StarshipMutation) Model() (r string, exists bool) {
	v := m.model
	if v == nil {
		return
	}
	return *v, true
}

// OldModel returns the old "model" field's value of the Starship entity.
// If the Starship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StarshipMutation) OldModel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModel: %w", err)
	}
	return oldValue.Model, nil
}

// ResetModel resets all changes to the "model" field.
func (m *StarshipMutation) ResetModel() {
	m.model = nil
}

// SetName sets the "name" field.
func (m *StarshipMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *StarshipMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Starship entity.
// If the Starship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StarshipMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *StarshipMutation) ResetName() {
	m.name = nil
}

// SetPassengerCapacity sets the "passenger_capacity" field.
func (m *StarshipMutation) SetPassengerCapacity(i int) {
	m.passenger_capacity = &i
	m.addpassenger_capacity = nil
}

// PassengerCapacity returns the value of the "passenger_capacity" field in the mutation.
func (m *StarshipMutation) PassengerCapacity() (r int, exists bool) {
	v := m.passenger_capacity
	if v == nil {
		return
	}
	return *v, true
}

// OldPassengerCapacity returns the old "passenger_capacity" field's value of the Starship entity.
// If the Starship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StarshipMutation) OldPassengerCapacity(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassengerCapacity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassengerCapacity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassengerCapacity: %w", err)
	}
	return oldValue.PassengerCapacity, nil
}

// AddPassengerCapacity adds i to the "passenger_capacity" field.
func (m *StarshipMutation) AddPassengerCapacity(i int) {
	if m.addpassenger_capacity != nil {
		*m.addpassenger_capacity += i
	} else {
		m.addpassenger_capacity = &i
	}
}

// AddedPassengerCapacity returns the value that was added to the "passenger_capacity" field in this mutation.
func (m *StarshipMutation) AddedPassengerCapacity() (r int, exists bool) {
	v := m.addpassenger_capacity
	if v == nil {
		return
	}
	return *v, true
}

// ClearPassengerCapacity clears the value of the "passenger_capacity" field.
func (m *StarshipMutation) ClearPassengerCapacity() {
	m.passenger_capacity = nil
	m.addpassenger_capacity = nil
	m.clearedFields[starship.FieldPassengerCapacity] = struct{}{}
}

// PassengerCapacityCleared returns if the "passenger_capacity" field was cleared in this mutation.
func (m *StarshipMutation) PassengerCapacityCleared() bool {
	_, ok := m.clearedFields[starship.FieldPassengerCapacity]
	return ok
}

// ResetPassengerCapacity resets all changes to the "passenger_capacity" field.
func (m *StarshipMutation) ResetPassengerCapacity() {
	m.passenger_capacity = nil
	m.addpassenger_capacity = nil
	delete(m.clearedFields, starship.FieldPassengerCapacity)
}

// AddAppearedInIDs adds the "appeared_in" edge to the Film entity by ids.
func (m *StarshipMutation) AddAppearedInIDs(ids ...int) {
	if m.appeared_in == nil {
		m.appeared_in = make(map[int]struct{})
	}
	for i := range ids {
		m.appeared_in[ids[i]] = struct{}{}
	}
}

// ClearAppearedIn clears the "appeared_in" edge to the Film entity.
func (m *StarshipMutation) ClearAppearedIn() {
	m.clearedappeared_in = true
}

// AppearedInCleared reports if the "appeared_in" edge to the Film entity was cleared.
func (m *StarshipMutation) AppearedInCleared() bool {
	return m.clearedappeared_in
}

// RemoveAppearedInIDs removes the "appeared_in" edge to the Film entity by IDs.
func (m *StarshipMutation) RemoveAppearedInIDs(ids ...int) {
	if m.removedappeared_in == nil {
		m.removedappeared_in = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.appeared_in, ids[i])
		m.removedappeared_in[ids[i]] = struct{}{}
	}
}

// RemovedAppearedIn returns the removed IDs of the "appeared_in" edge to the Film entity.
func (m *StarshipMutation) RemovedAppearedInIDs() (ids []int) {
	for id := range m.removedappeared_in {
		ids = append(ids, id)
	}
	return
}

// AppearedInIDs returns the "appeared_in" edge IDs in the mutation.
func (m *StarshipMutation) AppearedInIDs() (ids []int) {
	for id := range m.appeared_in {
		ids = append(ids, id)
	}
	return
}

// ResetAppearedIn resets all changes to the "appeared_in" edge.
func (m *StarshipMutation) ResetAppearedIn() {
	m.appeared_in = nil
	m.clearedappeared_in = false
	m.removedappeared_in = nil
}

// AddPilotedByIDs adds the "piloted_by" edge to the Person entity by ids.
func (m *StarshipMutation) AddPilotedByIDs(ids ...int) {
	if m.piloted_by == nil {
		m.piloted_by = make(map[int]struct{})
	}
	for i := range ids {
		m.piloted_by[ids[i]] = struct{}{}
	}
}

// ClearPilotedBy clears the "piloted_by" edge to the Person entity.
func (m *StarshipMutation) ClearPilotedBy() {
	m.clearedpiloted_by = true
}

// PilotedByCleared reports if the "piloted_by" edge to the Person entity was cleared.
func (m *StarshipMutation) PilotedByCleared() bool {
	return m.clearedpiloted_by
}

// RemovePilotedByIDs removes the "piloted_by" edge to the Person entity by IDs.
func (m *StarshipMutation) RemovePilotedByIDs(ids ...int) {
	if m.removedpiloted_by == nil {
		m.removedpiloted_by = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.piloted_by, ids[i])
		m.removedpiloted_by[ids[i]] = struct{}{}
	}
}

// RemovedPilotedBy returns the removed IDs of the "piloted_by" edge to the Person entity.
func (m *StarshipMutation) RemovedPilotedByIDs() (ids []int) {
	for id := range m.removedpiloted_by {
		ids = append(ids, id)
	}
	return
}

// PilotedByIDs returns the "piloted_by" edge IDs in the mutation.
func (m *StarshipMutation) PilotedByIDs() (ids []int) {
	for id := range m.piloted_by {
		ids = append(ids, id)
	}
	return
}

// ResetPilotedBy resets all changes to the "piloted_by" edge.
func (m *StarshipMutation) ResetPilotedBy() {
	m.piloted_by = nil
	m.clearedpiloted_by = false
	m.removedpiloted_by = nil
}

// Where appends a list predicates to the StarshipMutation builder.
func (m *StarshipMutation) Where(ps ...predicate.Starship) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *StarshipMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Starship).
func (m *StarshipMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StarshipMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.cargo_capacity != nil {
		fields = append(fields, starship.FieldCargoCapacity)
	}
	if m.class != nil {
		fields = append(fields, starship.FieldClass)
	}
	if m.consumables != nil {
		fields = append(fields, starship.FieldConsumables)
	}
	if m.cost_in_credits != nil {
		fields = append(fields, starship.FieldCostInCredits)
	}
	if m.crew != nil {
		fields = append(fields, starship.FieldCrew)
	}
	if m.hyperdrive_rating != nil {
		fields = append(fields, starship.FieldHyperdriveRating)
	}
	if m.length != nil {
		fields = append(fields, starship.FieldLength)
	}
	if m.manufacturer != nil {
		fields = append(fields, starship.FieldManufacturer)
	}
	if m.max_atmosphering_speed != nil {
		fields = append(fields, starship.FieldMaxAtmospheringSpeed)
	}
	if m.maximum_megalights != nil {
		fields = append(fields, starship.FieldMaximumMegalights)
	}
	if m.model != nil {
		fields = append(fields, starship.FieldModel)
	}
	if m.name != nil {
		fields = append(fields, starship.FieldName)
	}
	if m.passenger_capacity != nil {
		fields = append(fields, starship.FieldPassengerCapacity)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StarshipMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case starship.FieldCargoCapacity:
		return m.CargoCapacity()
	case starship.FieldClass:
		return m.Class()
	case starship.FieldConsumables:
		return m.Consumables()
	case starship.FieldCostInCredits:
		return m.CostInCredits()
	case starship.FieldCrew:
		return m.Crew()
	case starship.FieldHyperdriveRating:
		return m.HyperdriveRating()
	case starship.FieldLength:
		return m.Length()
	case starship.FieldManufacturer:
		return m.Manufacturer()
	case starship.FieldMaxAtmospheringSpeed:
		return m.MaxAtmospheringSpeed()
	case starship.FieldMaximumMegalights:
		return m.MaximumMegalights()
	case starship.FieldModel:
		return m.Model()
	case starship.FieldName:
		return m.Name()
	case starship.FieldPassengerCapacity:
		return m.PassengerCapacity()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StarshipMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case starship.FieldCargoCapacity:
		return m.OldCargoCapacity(ctx)
	case starship.FieldClass:
		return m.OldClass(ctx)
	case starship.FieldConsumables:
		return m.OldConsumables(ctx)
	case starship.FieldCostInCredits:
		return m.OldCostInCredits(ctx)
	case starship.FieldCrew:
		return m.OldCrew(ctx)
	case starship.FieldHyperdriveRating:
		return m.OldHyperdriveRating(ctx)
	case starship.FieldLength:
		return m.OldLength(ctx)
	case starship.FieldManufacturer:
		return m.OldManufacturer(ctx)
	case starship.FieldMaxAtmospheringSpeed:
		return m.OldMaxAtmospheringSpeed(ctx)
	case starship.FieldMaximumMegalights:
		return m.OldMaximumMegalights(ctx)
	case starship.FieldModel:
		return m.OldModel(ctx)
	case starship.FieldName:
		return m.OldName(ctx)
	case starship.FieldPassengerCapacity:
		return m.OldPassengerCapacity(ctx)
	}
	return nil, fmt.Errorf("unknown Starship field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StarshipMutation) SetField(name string, value ent.Value) error {
	switch name {
	case starship.FieldCargoCapacity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCargoCapacity(v)
		return nil
	case starship.FieldClass:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClass(v)
		return nil
	case starship.FieldConsumables:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConsumables(v)
		return nil
	case starship.FieldCostInCredits:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCostInCredits(v)
		return nil
	case starship.FieldCrew:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCrew(v)
		return nil
	case starship.FieldHyperdriveRating:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHyperdriveRating(v)
		return nil
	case starship.FieldLength:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLength(v)
		return nil
	case starship.FieldManufacturer:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetManufacturer(v)
		return nil
	case starship.FieldMaxAtmospheringSpeed:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxAtmospheringSpeed(v)
		return nil
	case starship.FieldMaximumMegalights:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaximumMegalights(v)
		return nil
	case starship.FieldModel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModel(v)
		return nil
	case starship.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case starship.FieldPassengerCapacity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassengerCapacity(v)
		return nil
	}
	return fmt.Errorf("unknown Starship field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StarshipMutation) AddedFields() []string {
	var fields []string
	if m.addcargo_capacity != nil {
		fields = append(fields, starship.FieldCargoCapacity)
	}
	if m.addcost_in_credits != nil {
		fields = append(fields, starship.FieldCostInCredits)
	}
	if m.addlength != nil {
		fields = append(fields, starship.FieldLength)
	}
	if m.addpassenger_capacity != nil {
		fields = append(fields, starship.FieldPassengerCapacity)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StarshipMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case starship.FieldCargoCapacity:
		return m.AddedCargoCapacity()
	case starship.FieldCostInCredits:
		return m.AddedCostInCredits()
	case starship.FieldLength:
		return m.AddedLength()
	case starship.FieldPassengerCapacity:
		return m.AddedPassengerCapacity()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StarshipMutation) AddField(name string, value ent.Value) error {
	switch name {
	case starship.FieldCargoCapacity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCargoCapacity(v)
		return nil
	case starship.FieldCostInCredits:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCostInCredits(v)
		return nil
	case starship.FieldLength:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLength(v)
		return nil
	case starship.FieldPassengerCapacity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPassengerCapacity(v)
		return nil
	}
	return fmt.Errorf("unknown Starship numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StarshipMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(starship.FieldCargoCapacity) {
		fields = append(fields, starship.FieldCargoCapacity)
	}
	if m.FieldCleared(starship.FieldMaximumMegalights) {
		fields = append(fields, starship.FieldMaximumMegalights)
	}
	if m.FieldCleared(starship.FieldPassengerCapacity) {
		fields = append(fields, starship.FieldPassengerCapacity)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StarshipMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StarshipMutation) ClearField(name string) error {
	switch name {
	case starship.FieldCargoCapacity:
		m.ClearCargoCapacity()
		return nil
	case starship.FieldMaximumMegalights:
		m.ClearMaximumMegalights()
		return nil
	case starship.FieldPassengerCapacity:
		m.ClearPassengerCapacity()
		return nil
	}
	return fmt.Errorf("unknown Starship nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StarshipMutation) ResetField(name string) error {
	switch name {
	case starship.FieldCargoCapacity:
		m.ResetCargoCapacity()
		return nil
	case starship.FieldClass:
		m.ResetClass()
		return nil
	case starship.FieldConsumables:
		m.ResetConsumables()
		return nil
	case starship.FieldCostInCredits:
		m.ResetCostInCredits()
		return nil
	case starship.FieldCrew:
		m.ResetCrew()
		return nil
	case starship.FieldHyperdriveRating:
		m.ResetHyperdriveRating()
		return nil
	case starship.FieldLength:
		m.ResetLength()
		return nil
	case starship.FieldManufacturer:
		m.ResetManufacturer()
		return nil
	case starship.FieldMaxAtmospheringSpeed:
		m.ResetMaxAtmospheringSpeed()
		return nil
	case starship.FieldMaximumMegalights:
		m.ResetMaximumMegalights()
		return nil
	case starship.FieldModel:
		m.ResetModel()
		return nil
	case starship.FieldName:
		m.ResetName()
		return nil
	case starship.FieldPassengerCapacity:
		m.ResetPassengerCapacity()
		return nil
	}
	return fmt.Errorf("unknown Starship field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StarshipMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.appeared_in != nil {
		edges = append(edges, starship.EdgeAppearedIn)
	}
	if m.piloted_by != nil {
		edges = append(edges, starship.EdgePilotedBy)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StarshipMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case starship.EdgeAppearedIn:
		ids := make([]ent.Value, 0, len(m.appeared_in))
		for id := range m.appeared_in {
			ids = append(ids, id)
		}
		return ids
	case starship.EdgePilotedBy:
		ids := make([]ent.Value, 0, len(m.piloted_by))
		for id := range m.piloted_by {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StarshipMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedappeared_in != nil {
		edges = append(edges, starship.EdgeAppearedIn)
	}
	if m.removedpiloted_by != nil {
		edges = append(edges, starship.EdgePilotedBy)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StarshipMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case starship.EdgeAppearedIn:
		ids := make([]ent.Value, 0, len(m.removedappeared_in))
		for id := range m.removedappeared_in {
			ids = append(ids, id)
		}
		return ids
	case starship.EdgePilotedBy:
		ids := make([]ent.Value, 0, len(m.removedpiloted_by))
		for id := range m.removedpiloted_by {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StarshipMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedappeared_in {
		edges = append(edges, starship.EdgeAppearedIn)
	}
	if m.clearedpiloted_by {
		edges = append(edges, starship.EdgePilotedBy)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StarshipMutation) EdgeCleared(name string) bool {
	switch name {
	case starship.EdgeAppearedIn:
		return m.clearedappeared_in
	case starship.EdgePilotedBy:
		return m.clearedpiloted_by
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StarshipMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Starship unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StarshipMutation) ResetEdge(name string) error {
	switch name {
	case starship.EdgeAppearedIn:
		m.ResetAppearedIn()
		return nil
	case starship.EdgePilotedBy:
		m.ResetPilotedBy()
		return nil
	}
	return fmt.Errorf("unknown Starship edge %s", name)
}

// VehicleMutation represents an operation that mutates the Vehicle nodes in the graph.
type VehicleMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	cargo_capacity         *int
	addcargo_capacity      *int
	consumables            *string
	cost_in_credits        *int
	addcost_in_credits     *int
	crew                   *string
	length                 *float64
	addlength              *float64
	manufacturer           *string
	max_atmosphering_speed *string
	model                  *string
	name                   *string
	passenger_capacity     *int
	addpassenger_capacity  *int
	clearedFields          map[string]struct{}
	appeared_in            map[int]struct{}
	removedappeared_in     map[int]struct{}
	clearedappeared_in     bool
	piloted_by             map[int]struct{}
	removedpiloted_by      map[int]struct{}
	clearedpiloted_by      bool
	done                   bool
	oldValue               func(context.Context) (*Vehicle, error)
	predicates             []predicate.Vehicle
}

var _ ent.Mutation = (*VehicleMutation)(nil)

// vehicleOption allows management of the mutation configuration using functional options.
type vehicleOption func(*VehicleMutation)

// newVehicleMutation creates new mutation for the Vehicle entity.
func newVehicleMutation(c config, op Op, opts ...vehicleOption) *VehicleMutation {
	m := &VehicleMutation{
		config:        c,
		op:            op,
		typ:           TypeVehicle,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVehicleID sets the ID field of the mutation.
func withVehicleID(id int) vehicleOption {
	return func(m *VehicleMutation) {
		var (
			err   error
			once  sync.Once
			value *Vehicle
		)
		m.oldValue = func(ctx context.Context) (*Vehicle, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Vehicle.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVehicle sets the old Vehicle of the mutation.
func withVehicle(node *Vehicle) vehicleOption {
	return func(m *VehicleMutation) {
		m.oldValue = func(context.Context) (*Vehicle, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VehicleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VehicleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VehicleMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VehicleMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Vehicle.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCargoCapacity sets the "cargo_capacity" field.
func (m *VehicleMutation) SetCargoCapacity(i int) {
	m.cargo_capacity = &i
	m.addcargo_capacity = nil
}

// CargoCapacity returns the value of the "cargo_capacity" field in the mutation.
func (m *VehicleMutation) CargoCapacity() (r int, exists bool) {
	v := m.cargo_capacity
	if v == nil {
		return
	}
	return *v, true
}

// OldCargoCapacity returns the old "cargo_capacity" field's value of the Vehicle entity.
// If the Vehicle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleMutation) OldCargoCapacity(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCargoCapacity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCargoCapacity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCargoCapacity: %w", err)
	}
	return oldValue.CargoCapacity, nil
}

// AddCargoCapacity adds i to the "cargo_capacity" field.
func (m *VehicleMutation) AddCargoCapacity(i int) {
	if m.addcargo_capacity != nil {
		*m.addcargo_capacity += i
	} else {
		m.addcargo_capacity = &i
	}
}

// AddedCargoCapacity returns the value that was added to the "cargo_capacity" field in this mutation.
func (m *VehicleMutation) AddedCargoCapacity() (r int, exists bool) {
	v := m.addcargo_capacity
	if v == nil {
		return
	}
	return *v, true
}

// ClearCargoCapacity clears the value of the "cargo_capacity" field.
func (m *VehicleMutation) ClearCargoCapacity() {
	m.cargo_capacity = nil
	m.addcargo_capacity = nil
	m.clearedFields[vehicle.FieldCargoCapacity] = struct{}{}
}

// CargoCapacityCleared returns if the "cargo_capacity" field was cleared in this mutation.
func (m *VehicleMutation) CargoCapacityCleared() bool {
	_, ok := m.clearedFields[vehicle.FieldCargoCapacity]
	return ok
}

// ResetCargoCapacity resets all changes to the "cargo_capacity" field.
func (m *VehicleMutation) ResetCargoCapacity() {
	m.cargo_capacity = nil
	m.addcargo_capacity = nil
	delete(m.clearedFields, vehicle.FieldCargoCapacity)
}

// SetConsumables sets the "consumables" field.
func (m *VehicleMutation) SetConsumables(s string) {
	m.consumables = &s
}

// Consumables returns the value of the "consumables" field in the mutation.
func (m *VehicleMutation) Consumables() (r string, exists bool) {
	v := m.consumables
	if v == nil {
		return
	}
	return *v, true
}

// OldConsumables returns the old "consumables" field's value of the Vehicle entity.
// If the Vehicle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleMutation) OldConsumables(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConsumables is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConsumables requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConsumables: %w", err)
	}
	return oldValue.Consumables, nil
}

// ResetConsumables resets all changes to the "consumables" field.
func (m *VehicleMutation) ResetConsumables() {
	m.consumables = nil
}

// SetCostInCredits sets the "cost_in_credits" field.
func (m *VehicleMutation) SetCostInCredits(i int) {
	m.cost_in_credits = &i
	m.addcost_in_credits = nil
}

// CostInCredits returns the value of the "cost_in_credits" field in the mutation.
func (m *VehicleMutation) CostInCredits() (r int, exists bool) {
	v := m.cost_in_credits
	if v == nil {
		return
	}
	return *v, true
}

// OldCostInCredits returns the old "cost_in_credits" field's value of the Vehicle entity.
// If the Vehicle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleMutation) OldCostInCredits(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCostInCredits is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCostInCredits requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCostInCredits: %w", err)
	}
	return oldValue.CostInCredits, nil
}

// AddCostInCredits adds i to the "cost_in_credits" field.
func (m *VehicleMutation) AddCostInCredits(i int) {
	if m.addcost_in_credits != nil {
		*m.addcost_in_credits += i
	} else {
		m.addcost_in_credits = &i
	}
}

// AddedCostInCredits returns the value that was added to the "cost_in_credits" field in this mutation.
func (m *VehicleMutation) AddedCostInCredits() (r int, exists bool) {
	v := m.addcost_in_credits
	if v == nil {
		return
	}
	return *v, true
}

// ResetCostInCredits resets all changes to the "cost_in_credits" field.
func (m *VehicleMutation) ResetCostInCredits() {
	m.cost_in_credits = nil
	m.addcost_in_credits = nil
}

// SetCrew sets the "crew" field.
func (m *VehicleMutation) SetCrew(s string) {
	m.crew = &s
}

// Crew returns the value of the "crew" field in the mutation.
func (m *VehicleMutation) Crew() (r string, exists bool) {
	v := m.crew
	if v == nil {
		return
	}
	return *v, true
}

// OldCrew returns the old "crew" field's value of the Vehicle entity.
// If the Vehicle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleMutation) OldCrew(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCrew is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCrew requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCrew: %w", err)
	}
	return oldValue.Crew, nil
}

// ResetCrew resets all changes to the "crew" field.
func (m *VehicleMutation) ResetCrew() {
	m.crew = nil
}

// SetLength sets the "length" field.
func (m *VehicleMutation) SetLength(f float64) {
	m.length = &f
	m.addlength = nil
}

// Length returns the value of the "length" field in the mutation.
func (m *VehicleMutation) Length() (r float64, exists bool) {
	v := m.length
	if v == nil {
		return
	}
	return *v, true
}

// OldLength returns the old "length" field's value of the Vehicle entity.
// If the Vehicle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleMutation) OldLength(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLength is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLength requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLength: %w", err)
	}
	return oldValue.Length, nil
}

// AddLength adds f to the "length" field.
func (m *VehicleMutation) AddLength(f float64) {
	if m.addlength != nil {
		*m.addlength += f
	} else {
		m.addlength = &f
	}
}

// AddedLength returns the value that was added to the "length" field in this mutation.
func (m *VehicleMutation) AddedLength() (r float64, exists bool) {
	v := m.addlength
	if v == nil {
		return
	}
	return *v, true
}

// ClearLength clears the value of the "length" field.
func (m *VehicleMutation) ClearLength() {
	m.length = nil
	m.addlength = nil
	m.clearedFields[vehicle.FieldLength] = struct{}{}
}

// LengthCleared returns if the "length" field was cleared in this mutation.
func (m *VehicleMutation) LengthCleared() bool {
	_, ok := m.clearedFields[vehicle.FieldLength]
	return ok
}

// ResetLength resets all changes to the "length" field.
func (m *VehicleMutation) ResetLength() {
	m.length = nil
	m.addlength = nil
	delete(m.clearedFields, vehicle.FieldLength)
}

// SetManufacturer sets the "manufacturer" field.
func (m *VehicleMutation) SetManufacturer(s string) {
	m.manufacturer = &s
}

// Manufacturer returns the value of the "manufacturer" field in the mutation.
func (m *VehicleMutation) Manufacturer() (r string, exists bool) {
	v := m.manufacturer
	if v == nil {
		return
	}
	return *v, true
}

// OldManufacturer returns the old "manufacturer" field's value of the Vehicle entity.
// If the Vehicle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleMutation) OldManufacturer(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldManufacturer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldManufacturer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldManufacturer: %w", err)
	}
	return oldValue.Manufacturer, nil
}

// ResetManufacturer resets all changes to the "manufacturer" field.
func (m *VehicleMutation) ResetManufacturer() {
	m.manufacturer = nil
}

// SetMaxAtmospheringSpeed sets the "max_atmosphering_speed" field.
func (m *VehicleMutation) SetMaxAtmospheringSpeed(s string) {
	m.max_atmosphering_speed = &s
}

// MaxAtmospheringSpeed returns the value of the "max_atmosphering_speed" field in the mutation.
func (m *VehicleMutation) MaxAtmospheringSpeed() (r string, exists bool) {
	v := m.max_atmosphering_speed
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxAtmospheringSpeed returns the old "max_atmosphering_speed" field's value of the Vehicle entity.
// If the Vehicle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleMutation) OldMaxAtmospheringSpeed(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxAtmospheringSpeed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxAtmospheringSpeed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxAtmospheringSpeed: %w", err)
	}
	return oldValue.MaxAtmospheringSpeed, nil
}

// ResetMaxAtmospheringSpeed resets all changes to the "max_atmosphering_speed" field.
func (m *VehicleMutation) ResetMaxAtmospheringSpeed() {
	m.max_atmosphering_speed = nil
}

// SetModel sets the "model" field.
func (m *VehicleMutation) SetModel(s string) {
	m.model = &s
}

// Model returns the value of the "model" field in the mutation.
func (m *VehicleMutation) Model() (r string, exists bool) {
	v := m.model
	if v == nil {
		return
	}
	return *v, true
}

// OldModel returns the old "model" field's value of the Vehicle entity.
// If the Vehicle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleMutation) OldModel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModel: %w", err)
	}
	return oldValue.Model, nil
}

// ResetModel resets all changes to the "model" field.
func (m *VehicleMutation) ResetModel() {
	m.model = nil
}

// SetName sets the "name" field.
func (m *VehicleMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *VehicleMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Vehicle entity.
// If the Vehicle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *VehicleMutation) ResetName() {
	m.name = nil
}

// SetPassengerCapacity sets the "passenger_capacity" field.
func (m *VehicleMutation) SetPassengerCapacity(i int) {
	m.passenger_capacity = &i
	m.addpassenger_capacity = nil
}

// PassengerCapacity returns the value of the "passenger_capacity" field in the mutation.
func (m *VehicleMutation) PassengerCapacity() (r int, exists bool) {
	v := m.passenger_capacity
	if v == nil {
		return
	}
	return *v, true
}

// OldPassengerCapacity returns the old "passenger_capacity" field's value of the Vehicle entity.
// If the Vehicle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleMutation) OldPassengerCapacity(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassengerCapacity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassengerCapacity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassengerCapacity: %w", err)
	}
	return oldValue.PassengerCapacity, nil
}

// AddPassengerCapacity adds i to the "passenger_capacity" field.
func (m *VehicleMutation) AddPassengerCapacity(i int) {
	if m.addpassenger_capacity != nil {
		*m.addpassenger_capacity += i
	} else {
		m.addpassenger_capacity = &i
	}
}

// AddedPassengerCapacity returns the value that was added to the "passenger_capacity" field in this mutation.
func (m *VehicleMutation) AddedPassengerCapacity() (r int, exists bool) {
	v := m.addpassenger_capacity
	if v == nil {
		return
	}
	return *v, true
}

// ClearPassengerCapacity clears the value of the "passenger_capacity" field.
func (m *VehicleMutation) ClearPassengerCapacity() {
	m.passenger_capacity = nil
	m.addpassenger_capacity = nil
	m.clearedFields[vehicle.FieldPassengerCapacity] = struct{}{}
}

// PassengerCapacityCleared returns if the "passenger_capacity" field was cleared in this mutation.
func (m *VehicleMutation) PassengerCapacityCleared() bool {
	_, ok := m.clearedFields[vehicle.FieldPassengerCapacity]
	return ok
}

// ResetPassengerCapacity resets all changes to the "passenger_capacity" field.
func (m *VehicleMutation) ResetPassengerCapacity() {
	m.passenger_capacity = nil
	m.addpassenger_capacity = nil
	delete(m.clearedFields, vehicle.FieldPassengerCapacity)
}

// AddAppearedInIDs adds the "appeared_in" edge to the Film entity by ids.
func (m *VehicleMutation) AddAppearedInIDs(ids ...int) {
	if m.appeared_in == nil {
		m.appeared_in = make(map[int]struct{})
	}
	for i := range ids {
		m.appeared_in[ids[i]] = struct{}{}
	}
}

// ClearAppearedIn clears the "appeared_in" edge to the Film entity.
func (m *VehicleMutation) ClearAppearedIn() {
	m.clearedappeared_in = true
}

// AppearedInCleared reports if the "appeared_in" edge to the Film entity was cleared.
func (m *VehicleMutation) AppearedInCleared() bool {
	return m.clearedappeared_in
}

// RemoveAppearedInIDs removes the "appeared_in" edge to the Film entity by IDs.
func (m *VehicleMutation) RemoveAppearedInIDs(ids ...int) {
	if m.removedappeared_in == nil {
		m.removedappeared_in = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.appeared_in, ids[i])
		m.removedappeared_in[ids[i]] = struct{}{}
	}
}

// RemovedAppearedIn returns the removed IDs of the "appeared_in" edge to the Film entity.
func (m *VehicleMutation) RemovedAppearedInIDs() (ids []int) {
	for id := range m.removedappeared_in {
		ids = append(ids, id)
	}
	return
}

// AppearedInIDs returns the "appeared_in" edge IDs in the mutation.
func (m *VehicleMutation) AppearedInIDs() (ids []int) {
	for id := range m.appeared_in {
		ids = append(ids, id)
	}
	return
}

// ResetAppearedIn resets all changes to the "appeared_in" edge.
func (m *VehicleMutation) ResetAppearedIn() {
	m.appeared_in = nil
	m.clearedappeared_in = false
	m.removedappeared_in = nil
}

// AddPilotedByIDs adds the "piloted_by" edge to the Person entity by ids.
func (m *VehicleMutation) AddPilotedByIDs(ids ...int) {
	if m.piloted_by == nil {
		m.piloted_by = make(map[int]struct{})
	}
	for i := range ids {
		m.piloted_by[ids[i]] = struct{}{}
	}
}

// ClearPilotedBy clears the "piloted_by" edge to the Person entity.
func (m *VehicleMutation) ClearPilotedBy() {
	m.clearedpiloted_by = true
}

// PilotedByCleared reports if the "piloted_by" edge to the Person entity was cleared.
func (m *VehicleMutation) PilotedByCleared() bool {
	return m.clearedpiloted_by
}

// RemovePilotedByIDs removes the "piloted_by" edge to the Person entity by IDs.
func (m *VehicleMutation) RemovePilotedByIDs(ids ...int) {
	if m.removedpiloted_by == nil {
		m.removedpiloted_by = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.piloted_by, ids[i])
		m.removedpiloted_by[ids[i]] = struct{}{}
	}
}

// RemovedPilotedBy returns the removed IDs of the "piloted_by" edge to the Person entity.
func (m *VehicleMutation) RemovedPilotedByIDs() (ids []int) {
	for id := range m.removedpiloted_by {
		ids = append(ids, id)
	}
	return
}

// PilotedByIDs returns the "piloted_by" edge IDs in the mutation.
func (m *VehicleMutation) PilotedByIDs() (ids []int) {
	for id := range m.piloted_by {
		ids = append(ids, id)
	}
	return
}

// ResetPilotedBy resets all changes to the "piloted_by" edge.
func (m *VehicleMutation) ResetPilotedBy() {
	m.piloted_by = nil
	m.clearedpiloted_by = false
	m.removedpiloted_by = nil
}

// Where appends a list predicates to the VehicleMutation builder.
func (m *VehicleMutation) Where(ps ...predicate.Vehicle) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *VehicleMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Vehicle).
func (m *VehicleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VehicleMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.cargo_capacity != nil {
		fields = append(fields, vehicle.FieldCargoCapacity)
	}
	if m.consumables != nil {
		fields = append(fields, vehicle.FieldConsumables)
	}
	if m.cost_in_credits != nil {
		fields = append(fields, vehicle.FieldCostInCredits)
	}
	if m.crew != nil {
		fields = append(fields, vehicle.FieldCrew)
	}
	if m.length != nil {
		fields = append(fields, vehicle.FieldLength)
	}
	if m.manufacturer != nil {
		fields = append(fields, vehicle.FieldManufacturer)
	}
	if m.max_atmosphering_speed != nil {
		fields = append(fields, vehicle.FieldMaxAtmospheringSpeed)
	}
	if m.model != nil {
		fields = append(fields, vehicle.FieldModel)
	}
	if m.name != nil {
		fields = append(fields, vehicle.FieldName)
	}
	if m.passenger_capacity != nil {
		fields = append(fields, vehicle.FieldPassengerCapacity)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VehicleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case vehicle.FieldCargoCapacity:
		return m.CargoCapacity()
	case vehicle.FieldConsumables:
		return m.Consumables()
	case vehicle.FieldCostInCredits:
		return m.CostInCredits()
	case vehicle.FieldCrew:
		return m.Crew()
	case vehicle.FieldLength:
		return m.Length()
	case vehicle.FieldManufacturer:
		return m.Manufacturer()
	case vehicle.FieldMaxAtmospheringSpeed:
		return m.MaxAtmospheringSpeed()
	case vehicle.FieldModel:
		return m.Model()
	case vehicle.FieldName:
		return m.Name()
	case vehicle.FieldPassengerCapacity:
		return m.PassengerCapacity()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VehicleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case vehicle.FieldCargoCapacity:
		return m.OldCargoCapacity(ctx)
	case vehicle.FieldConsumables:
		return m.OldConsumables(ctx)
	case vehicle.FieldCostInCredits:
		return m.OldCostInCredits(ctx)
	case vehicle.FieldCrew:
		return m.OldCrew(ctx)
	case vehicle.FieldLength:
		return m.OldLength(ctx)
	case vehicle.FieldManufacturer:
		return m.OldManufacturer(ctx)
	case vehicle.FieldMaxAtmospheringSpeed:
		return m.OldMaxAtmospheringSpeed(ctx)
	case vehicle.FieldModel:
		return m.OldModel(ctx)
	case vehicle.FieldName:
		return m.OldName(ctx)
	case vehicle.FieldPassengerCapacity:
		return m.OldPassengerCapacity(ctx)
	}
	return nil, fmt.Errorf("unknown Vehicle field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VehicleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case vehicle.FieldCargoCapacity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCargoCapacity(v)
		return nil
	case vehicle.FieldConsumables:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConsumables(v)
		return nil
	case vehicle.FieldCostInCredits:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCostInCredits(v)
		return nil
	case vehicle.FieldCrew:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCrew(v)
		return nil
	case vehicle.FieldLength:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLength(v)
		return nil
	case vehicle.FieldManufacturer:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetManufacturer(v)
		return nil
	case vehicle.FieldMaxAtmospheringSpeed:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxAtmospheringSpeed(v)
		return nil
	case vehicle.FieldModel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModel(v)
		return nil
	case vehicle.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case vehicle.FieldPassengerCapacity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassengerCapacity(v)
		return nil
	}
	return fmt.Errorf("unknown Vehicle field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VehicleMutation) AddedFields() []string {
	var fields []string
	if m.addcargo_capacity != nil {
		fields = append(fields, vehicle.FieldCargoCapacity)
	}
	if m.addcost_in_credits != nil {
		fields = append(fields, vehicle.FieldCostInCredits)
	}
	if m.addlength != nil {
		fields = append(fields, vehicle.FieldLength)
	}
	if m.addpassenger_capacity != nil {
		fields = append(fields, vehicle.FieldPassengerCapacity)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VehicleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case vehicle.FieldCargoCapacity:
		return m.AddedCargoCapacity()
	case vehicle.FieldCostInCredits:
		return m.AddedCostInCredits()
	case vehicle.FieldLength:
		return m.AddedLength()
	case vehicle.FieldPassengerCapacity:
		return m.AddedPassengerCapacity()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VehicleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case vehicle.FieldCargoCapacity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCargoCapacity(v)
		return nil
	case vehicle.FieldCostInCredits:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCostInCredits(v)
		return nil
	case vehicle.FieldLength:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLength(v)
		return nil
	case vehicle.FieldPassengerCapacity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPassengerCapacity(v)
		return nil
	}
	return fmt.Errorf("unknown Vehicle numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VehicleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(vehicle.FieldCargoCapacity) {
		fields = append(fields, vehicle.FieldCargoCapacity)
	}
	if m.FieldCleared(vehicle.FieldLength) {
		fields = append(fields, vehicle.FieldLength)
	}
	if m.FieldCleared(vehicle.FieldPassengerCapacity) {
		fields = append(fields, vehicle.FieldPassengerCapacity)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VehicleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VehicleMutation) ClearField(name string) error {
	switch name {
	case vehicle.FieldCargoCapacity:
		m.ClearCargoCapacity()
		return nil
	case vehicle.FieldLength:
		m.ClearLength()
		return nil
	case vehicle.FieldPassengerCapacity:
		m.ClearPassengerCapacity()
		return nil
	}
	return fmt.Errorf("unknown Vehicle nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VehicleMutation) ResetField(name string) error {
	switch name {
	case vehicle.FieldCargoCapacity:
		m.ResetCargoCapacity()
		return nil
	case vehicle.FieldConsumables:
		m.ResetConsumables()
		return nil
	case vehicle.FieldCostInCredits:
		m.ResetCostInCredits()
		return nil
	case vehicle.FieldCrew:
		m.ResetCrew()
		return nil
	case vehicle.FieldLength:
		m.ResetLength()
		return nil
	case vehicle.FieldManufacturer:
		m.ResetManufacturer()
		return nil
	case vehicle.FieldMaxAtmospheringSpeed:
		m.ResetMaxAtmospheringSpeed()
		return nil
	case vehicle.FieldModel:
		m.ResetModel()
		return nil
	case vehicle.FieldName:
		m.ResetName()
		return nil
	case vehicle.FieldPassengerCapacity:
		m.ResetPassengerCapacity()
		return nil
	}
	return fmt.Errorf("unknown Vehicle field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VehicleMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.appeared_in != nil {
		edges = append(edges, vehicle.EdgeAppearedIn)
	}
	if m.piloted_by != nil {
		edges = append(edges, vehicle.EdgePilotedBy)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VehicleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case vehicle.EdgeAppearedIn:
		ids := make([]ent.Value, 0, len(m.appeared_in))
		for id := range m.appeared_in {
			ids = append(ids, id)
		}
		return ids
	case vehicle.EdgePilotedBy:
		ids := make([]ent.Value, 0, len(m.piloted_by))
		for id := range m.piloted_by {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VehicleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedappeared_in != nil {
		edges = append(edges, vehicle.EdgeAppearedIn)
	}
	if m.removedpiloted_by != nil {
		edges = append(edges, vehicle.EdgePilotedBy)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VehicleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case vehicle.EdgeAppearedIn:
		ids := make([]ent.Value, 0, len(m.removedappeared_in))
		for id := range m.removedappeared_in {
			ids = append(ids, id)
		}
		return ids
	case vehicle.EdgePilotedBy:
		ids := make([]ent.Value, 0, len(m.removedpiloted_by))
		for id := range m.removedpiloted_by {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VehicleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedappeared_in {
		edges = append(edges, vehicle.EdgeAppearedIn)
	}
	if m.clearedpiloted_by {
		edges = append(edges, vehicle.EdgePilotedBy)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VehicleMutation) EdgeCleared(name string) bool {
	switch name {
	case vehicle.EdgeAppearedIn:
		return m.clearedappeared_in
	case vehicle.EdgePilotedBy:
		return m.clearedpiloted_by
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VehicleMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Vehicle unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VehicleMutation) ResetEdge(name string) error {
	switch name {
	case vehicle.EdgeAppearedIn:
		m.ResetAppearedIn()
		return nil
	case vehicle.EdgePilotedBy:
		m.ResetPilotedBy()
		return nil
	}
	return fmt.Errorf("unknown Vehicle edge %s", name)
}
