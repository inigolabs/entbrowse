// Code generated by entc, DO NOT EDIT.

package ent

import (
	"fmt"
	"strings"

	"entgo.io/ent/dialect/sql"
	"github.com/inigolabs/entbrowse/starwars/ent/gen/ent/person"
)

// Person is the model entity for the Person schema.
type Person struct {
	config `json:"-"`
	// ID of the ent.
	ID int `json:"id,omitempty"`
	// BirthYear holds the value of the "birth_year" field.
	BirthYear string `json:"birth_year,omitempty"`
	// EyeColor holds the value of the "eye_color" field.
	EyeColor string `json:"eye_color,omitempty"`
	// Gender holds the value of the "gender" field.
	Gender string `json:"gender,omitempty"`
	// HairColor holds the value of the "hair_color" field.
	HairColor string `json:"hair_color,omitempty"`
	// Height holds the value of the "height" field.
	Height int `json:"height,omitempty"`
	// Mass holds the value of the "mass" field.
	Mass *float64 `json:"mass,omitempty"`
	// Name holds the value of the "name" field.
	Name string `json:"name,omitempty"`
	// SkinColor holds the value of the "skin_color" field.
	SkinColor string `json:"skin_color,omitempty"`
	// Edges holds the relations/edges for other nodes in the graph.
	// The values are being populated by the PersonQuery when eager-loading is set.
	Edges PersonEdges `json:"edges"`
}

// PersonEdges holds the relations/edges for other nodes in the graph.
type PersonEdges struct {
	// PilotedStarship holds the value of the piloted_starship edge.
	PilotedStarship []*Starship `json:"piloted_starship,omitempty"`
	// PilotedVehicle holds the value of the piloted_vehicle edge.
	PilotedVehicle []*Vehicle `json:"piloted_vehicle,omitempty"`
	// IsOfType holds the value of the is_of_type edge.
	IsOfType []*Species `json:"is_of_type,omitempty"`
	// AppearedIn holds the value of the appeared_in edge.
	AppearedIn []*Film `json:"appeared_in,omitempty"`
	// FromPlanet holds the value of the from_planet edge.
	FromPlanet []*Planet `json:"from_planet,omitempty"`
	// loadedTypes holds the information for reporting if a
	// type was loaded (or requested) in eager-loading or not.
	loadedTypes [5]bool
}

// PilotedStarshipOrErr returns the PilotedStarship value or an error if the edge
// was not loaded in eager-loading.
func (e PersonEdges) PilotedStarshipOrErr() ([]*Starship, error) {
	if e.loadedTypes[0] {
		return e.PilotedStarship, nil
	}
	return nil, &NotLoadedError{edge: "piloted_starship"}
}

// PilotedVehicleOrErr returns the PilotedVehicle value or an error if the edge
// was not loaded in eager-loading.
func (e PersonEdges) PilotedVehicleOrErr() ([]*Vehicle, error) {
	if e.loadedTypes[1] {
		return e.PilotedVehicle, nil
	}
	return nil, &NotLoadedError{edge: "piloted_vehicle"}
}

// IsOfTypeOrErr returns the IsOfType value or an error if the edge
// was not loaded in eager-loading.
func (e PersonEdges) IsOfTypeOrErr() ([]*Species, error) {
	if e.loadedTypes[2] {
		return e.IsOfType, nil
	}
	return nil, &NotLoadedError{edge: "is_of_type"}
}

// AppearedInOrErr returns the AppearedIn value or an error if the edge
// was not loaded in eager-loading.
func (e PersonEdges) AppearedInOrErr() ([]*Film, error) {
	if e.loadedTypes[3] {
		return e.AppearedIn, nil
	}
	return nil, &NotLoadedError{edge: "appeared_in"}
}

// FromPlanetOrErr returns the FromPlanet value or an error if the edge
// was not loaded in eager-loading.
func (e PersonEdges) FromPlanetOrErr() ([]*Planet, error) {
	if e.loadedTypes[4] {
		return e.FromPlanet, nil
	}
	return nil, &NotLoadedError{edge: "from_planet"}
}

// scanValues returns the types for scanning values from sql.Rows.
func (*Person) scanValues(columns []string) ([]interface{}, error) {
	values := make([]interface{}, len(columns))
	for i := range columns {
		switch columns[i] {
		case person.FieldMass:
			values[i] = new(sql.NullFloat64)
		case person.FieldID, person.FieldHeight:
			values[i] = new(sql.NullInt64)
		case person.FieldBirthYear, person.FieldEyeColor, person.FieldGender, person.FieldHairColor, person.FieldName, person.FieldSkinColor:
			values[i] = new(sql.NullString)
		default:
			return nil, fmt.Errorf("unexpected column %q for type Person", columns[i])
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the Person fields.
func (pe *Person) assignValues(columns []string, values []interface{}) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case person.FieldID:
			value, ok := values[i].(*sql.NullInt64)
			if !ok {
				return fmt.Errorf("unexpected type %T for field id", value)
			}
			pe.ID = int(value.Int64)
		case person.FieldBirthYear:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field birth_year", values[i])
			} else if value.Valid {
				pe.BirthYear = value.String
			}
		case person.FieldEyeColor:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field eye_color", values[i])
			} else if value.Valid {
				pe.EyeColor = value.String
			}
		case person.FieldGender:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field gender", values[i])
			} else if value.Valid {
				pe.Gender = value.String
			}
		case person.FieldHairColor:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field hair_color", values[i])
			} else if value.Valid {
				pe.HairColor = value.String
			}
		case person.FieldHeight:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field height", values[i])
			} else if value.Valid {
				pe.Height = int(value.Int64)
			}
		case person.FieldMass:
			if value, ok := values[i].(*sql.NullFloat64); !ok {
				return fmt.Errorf("unexpected type %T for field mass", values[i])
			} else if value.Valid {
				pe.Mass = new(float64)
				*pe.Mass = value.Float64
			}
		case person.FieldName:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field name", values[i])
			} else if value.Valid {
				pe.Name = value.String
			}
		case person.FieldSkinColor:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field skin_color", values[i])
			} else if value.Valid {
				pe.SkinColor = value.String
			}
		}
	}
	return nil
}

// QueryPilotedStarship queries the "piloted_starship" edge of the Person entity.
func (pe *Person) QueryPilotedStarship() *StarshipQuery {
	return (&PersonClient{config: pe.config}).QueryPilotedStarship(pe)
}

// QueryPilotedVehicle queries the "piloted_vehicle" edge of the Person entity.
func (pe *Person) QueryPilotedVehicle() *VehicleQuery {
	return (&PersonClient{config: pe.config}).QueryPilotedVehicle(pe)
}

// QueryIsOfType queries the "is_of_type" edge of the Person entity.
func (pe *Person) QueryIsOfType() *SpeciesQuery {
	return (&PersonClient{config: pe.config}).QueryIsOfType(pe)
}

// QueryAppearedIn queries the "appeared_in" edge of the Person entity.
func (pe *Person) QueryAppearedIn() *FilmQuery {
	return (&PersonClient{config: pe.config}).QueryAppearedIn(pe)
}

// QueryFromPlanet queries the "from_planet" edge of the Person entity.
func (pe *Person) QueryFromPlanet() *PlanetQuery {
	return (&PersonClient{config: pe.config}).QueryFromPlanet(pe)
}

// Update returns a builder for updating this Person.
// Note that you need to call Person.Unwrap() before calling this method if this Person
// was returned from a transaction, and the transaction was committed or rolled back.
func (pe *Person) Update() *PersonUpdateOne {
	return (&PersonClient{config: pe.config}).UpdateOne(pe)
}

// Unwrap unwraps the Person entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (pe *Person) Unwrap() *Person {
	tx, ok := pe.config.driver.(*txDriver)
	if !ok {
		panic("ent: Person is not a transactional entity")
	}
	pe.config.driver = tx.drv
	return pe
}

// String implements the fmt.Stringer.
func (pe *Person) String() string {
	var builder strings.Builder
	builder.WriteString("Person(")
	builder.WriteString(fmt.Sprintf("id=%v", pe.ID))
	builder.WriteString(", birth_year=")
	builder.WriteString(pe.BirthYear)
	builder.WriteString(", eye_color=")
	builder.WriteString(pe.EyeColor)
	builder.WriteString(", gender=")
	builder.WriteString(pe.Gender)
	builder.WriteString(", hair_color=")
	builder.WriteString(pe.HairColor)
	builder.WriteString(", height=")
	builder.WriteString(fmt.Sprintf("%v", pe.Height))
	if v := pe.Mass; v != nil {
		builder.WriteString(", mass=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", name=")
	builder.WriteString(pe.Name)
	builder.WriteString(", skin_color=")
	builder.WriteString(pe.SkinColor)
	builder.WriteByte(')')
	return builder.String()
}

// Persons is a parsable slice of Person.
type Persons []*Person

func (pe Persons) config(cfg config) {
	for _i := range pe {
		pe[_i].config = cfg
	}
}
